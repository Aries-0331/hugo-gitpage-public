<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>crypto on urchinzhou</title>
    <link>https://urchinzhou.com/categories/crypto/</link>
    <description>Recent content in crypto on urchinzhou</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 04 Nov 2022 17:13:59 +0800</lastBuildDate><atom:link href="https://urchinzhou.com/categories/crypto/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于QUIC Crypto</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Equic-crypto/</link>
      <pubDate>Fri, 04 Nov 2022 17:13:59 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Equic-crypto/</guid>
      <description>&lt;h1 id=&#34;简要介绍&#34;&gt;简要介绍&lt;/h1&gt;
&lt;p&gt;QUIC（Quick UDP Internet Connections）是一种默认加密的互联网传输协议，旨在提供安全、快速的 HTTP 传输，以替代 TCP 和 TLS。Google QUIC 的默认加密协议是自家的 QUIC Crypto。&lt;/p&gt;
&lt;p&gt;QUIC 与 TCP 的根本不同在于默认提供安全传输的设计原则。最初的 QUIC 结合了 TCP 的三次握手以及 TLS 1.3 的握手，并将 TLS的记录层数据帧格式替换为 QUIC 自己的，同时保留了 TLS 的握手消息。这种做法既保证了连接总是经过认证和加密的，同时使得初始连接建立速度更快。TCP 和 TLS1.3 完成握手需要两轮交互，而 QUIC 握手仅需一轮，如果客户端缓存了服务端的配置信息，那么甚至无需握手。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://blog.cloudflare.com/content/images/2018/07/http-request-over-tcp-tls@2x.png&#34; width=&#34;600&#34;&gt;
&lt;img src=&#34;https://blog.cloudflare.com/content/images/2018/07/http-request-over-quic@2x.png&#34; width=&#34;600&#34;&gt;
&lt;/div&gt;
&lt;h1 id=&#34;协商成本对比&#34;&gt;协商成本对比&lt;/h1&gt;
&lt;h2 id=&#34;quic&#34;&gt;QUIC&lt;/h2&gt;
&lt;p&gt;QUIC 的服务端有一个使用私钥签名的&lt;code&gt;server config&lt;/code&gt;参数列表，包含常规参数、 DH 公钥、有效期等信息，由于这些数据都是静态的，所以一次签名后可以长期使用，不需要每次建立连接时都签名。&lt;/p&gt;
&lt;p&gt;通道密钥协商使用&lt;code&gt;Diffie-Hellman&lt;/code&gt;，DH 算法所需要的服务端参数在&lt;code&gt;server config&lt;/code&gt;中，客户端参数通过第一个握手消息传递至服务端。为了实现 0-RTT 握手而设计的静态 &lt;code&gt;server config&lt;/code&gt;，同时也带来了加密连接的前向安全问题 —— 只要服务端还保存有 &lt;code&gt;server config&lt;/code&gt;，那么一旦密钥泄露，之前使用该密钥加密的数据都是可破解的。&lt;/p&gt;
&lt;p&gt;因此 QUIC 提供了两级加密：来自客户端的初始数据使用&lt;code&gt;server config&lt;/code&gt;中的 DH 值加密，该值可持久化存储几天，服务端收到客户端的连接后，立即回复一个临时的 DH 值，并重新加密连接。&lt;/p&gt;
&lt;p&gt;虽然乍一看这种做法没有 TLS1.3 所实现的前向安全更完善，但实际上， TLS 在大规模部署时为了减少网络交互，通常会启用 &lt;code&gt;SessionTickets&lt;/code&gt;，而&lt;code&gt;SessionTickets&lt;/code&gt;同样会持久化存储，并被用于破解加密连接，&lt;code&gt;server config&lt;/code&gt;和&lt;code&gt;SessionTickets&lt;/code&gt;可以说是半斤八两，相较而言 QUIC 提供了临时密钥用于实际通信，反而稍强于 TLS 的做法。&lt;/p&gt;
&lt;p&gt;每个连接使用一个临时密钥，与所有连接共用一个临时密钥，在安全性上的差异可以忽略不计，而牺牲这点安全性差异所带来的复杂度打折是很可观的，所以不妨在较短的时间跨度内，将服务器的 DH 密钥复用至所有连接上。&lt;/p&gt;
&lt;h2 id=&#34;tls13&#34;&gt;TLS1.3&lt;/h2&gt;
&lt;p&gt;TLS1.3 的握手主要做三件事情：密钥交换、获取服务器参数、认证；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;密钥交换：该阶段共享生成密钥所需的材料，例如所属计算方式或命名组（ECDHE or DHE），选择密码参数，例如对称加密选项；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器参数：该阶段确认其它握手参数，例如是否需要基于数字证书的客户端认证；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;认证：该阶段对服务端进行认证，对客户端选择性认证，并对密钥进行校验以及握手信息的完整性校验；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TLS 的握手分两种：非前向安全握手和前向安全握手，其与 QUIC 的握手效率对比大概为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于非前向安全握手，客户端做一次公钥加密约34us，服务端做一次私钥解密约1100us；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于前向安全握手，客户端做一次公钥加密、一次DH运算、一次伪随机数运算，大约耗时230us，服务端做一次私钥解密、一次DH运算、一次伪随机数运算，大约耗时1300us；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QUIC 客户端做一次 DH 运算、两次随机数运算、一次公钥加密，约耗时 184us，服务端做两次随机数运算，约耗时100us；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出 QUIC 与 TLS 在协商阶段的成本差异主要是非对称加解密造成的，当然这里没有包含校验证书链等操作，因为两个协议都有，并且默认两种协议所选的密码算法与选项相同或处于统一性能等级，比如摘要都用SHA-256、DH 曲线都用 Curve25519，如果给 QUIC 选 ECDH P-256 而 TLS 选 Curve25519，那就是另一种结果了。&lt;/p&gt;
&lt;p&gt;另外，TLS 有会话恢复机制，而 QUIC 则需要由 C/S 两端各自维护 DH 结果的缓存，虽然没有在协议层面支持这一特性，但牺牲这一便利而带来了大约5倍的效率提升，还是不错的。&lt;/p&gt;
&lt;h1 id=&#34;quic-handshake&#34;&gt;QUIC handshake&lt;/h1&gt;
&lt;p&gt;QUIC 的协商过程可以简单总结出三个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;server config&lt;/code&gt;是一个包含服务端临时密钥的参数集，大概每几天更新一次；&lt;/li&gt;
&lt;li&gt;初次建立连接时的 client hello 其实就是个空的消息，目的就是从 server 获取包含最新 &lt;code&gt;server config&lt;/code&gt; 的REJ(ect)消息，获取到后会重新发起正式的 client hello；&lt;/li&gt;
&lt;li&gt;server hello 是包含临时密钥的加密消息；&lt;/li&gt;
&lt;/ul&gt;
&lt;div align=center&gt;
  &lt;img src=&#34;https://lh4.googleusercontent.com/DLKsceJfawl4pkbWeaTx69tgW97gG4TQ3BNWBPF3YgtqbkKhHmzgSyL7iajoAibBW9qRx7DcJiCwF2dGZngMFRI3pylhbttoRKZ6LLvQEJuvRepn8gOeya9FrfYd_PvVGRswL6uQCexAimZZdBuUwI5ttPH_mo-i2bVKQFxu9jMosswjo2e4FQvn0YHq&#34; width=500&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;首次连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现 0-RTT handshake，客户端需要获取&lt;code&gt;server config&lt;/code&gt;，因此首次连接的成本是 1-RTT。&lt;/p&gt;
&lt;p&gt;当客户端第一次建立连接时，在握手成功前，客户端会先发送一个不完整的 &lt;code&gt;hello message&lt;/code&gt;以获取服务期配置及其真实性证明，而服务端为了避免向任意未证实的端发送大量真实性证明，因此需要验证客户端身份，这一过程可能会有多次交互，不过这些是一次性的。&lt;/p&gt;
&lt;p&gt;客户端的&lt;code&gt;hello message&lt;/code&gt;中包含一些键值对，例如服务端域名、源地址token、可接受的认证类型、通用证书集合、缓存的证书等（部分是可选的），主要用来表明身份，在收到客户端的&lt;code&gt;hello message&lt;/code&gt;后，服务端将返回拒绝消息或&lt;code&gt;server hello&lt;/code&gt;。hello 表示握手成功，拒绝消息则会附带供客户端握手使用的一些信息。&lt;/p&gt;
&lt;p&gt;例如，若客户端没有携带源地址token，而服务端不想给未认证的IP源发送&lt;code&gt;server config&lt;/code&gt;，那么服务端会在拒绝消息中携带源地址token，以便客户端的下次握手校验能通过。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server config&lt;/code&gt;通过键值对描述服务端的一系列参数，包含 server config ID、密钥交换算法、认证加密算法、公钥列表、有效期、版本等。客户端收到&lt;code&gt;server config&lt;/code&gt;后，通过证书链和签名来进行认证，然后就可以发送不会失败的完整握手消息。完整的握手消息除了上述不完整的消息内容外，还包含客户端使用的 server config ID、认证加密算法、密钥家换算法、客户端随机数、服务端随机数、公钥等。&lt;/p&gt;
&lt;p&gt;发送完整的&lt;code&gt;hello message&lt;/code&gt;后，双方就共同拥有了一个非前向安全密钥（也可称为初始密钥），此时客户端就可以给服务端开始发送应用数据了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非首次连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端在首次连接后，会把&lt;code&gt;server config&lt;/code&gt;存下来，之后再发起连接时，可直接发送业务数据，以此来实现 0-RTT。&lt;/p&gt;
&lt;h1 id=&#34;tls13状态机&#34;&gt;TLS1.3状态机&lt;/h1&gt;
&lt;div align=center&gt;&lt;img src=&#34;https://cryptologie.net/upload/sm1.png&#34; width=800&gt;&lt;/div&gt;
&lt;p&gt;从握手的状态图可以很快做出判断，TLS 比 QUIC 复杂好多。TLS 是一个相对可靠、完善的协议，但同时由于版本迭代较多，大量历史遗留问题导致其架构、接口、用例非常复杂，如果不考虑历史包袱等兼容性问题，应该可以设计出更优雅的“TLS”。&lt;/p&gt;
&lt;h1 id=&#34;密钥派生&#34;&gt;密钥派生&lt;/h1&gt;
&lt;p&gt;QUIC 的密钥材料通过 HMAC-SHA256 密钥派生函数（HKDF）生成，HKDF 采用先提取再扩展的设计方式，先将输入的字符转换为固定长度的伪随机数，然后将其扩展成若干个伪随机密钥。在 QUIC 的实现中，密钥协商阶段生成的 DH 密钥便是 HKDF 的输入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HKDF-Extract&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用原始的密钥材料，派生出一个符合密码学强度的伪随机密钥。HKDF-Extract 的输入包含客户端、服务端的nonce以及密钥协商输出的密钥（pre-master key），HKDF-Extract 的输出是一个伪随机密钥，作为主密钥，长度 32 bytes（前提是使用 SHA-256 作为摘要算法）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HKDF-Expand&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 HKDF-Expand 提取出来的伪随机密钥，扩展出指定长度的密钥（同时保证随机性）。以 HKDF-Extract 生成的 pre-master key 和下列信息作为输入，以生成 forward-secret key：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QUIC key expansion&lt;/li&gt;
&lt;li&gt;连接的 GUID&lt;/li&gt;
&lt;li&gt;client hello message&lt;/li&gt;
&lt;li&gt;server config&lt;/li&gt;
&lt;li&gt;DER 编码证书&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结来看就是，client hello message 获取到 server config，并生成 dh key，以该 key 作为 HKDF-Extract 的输入，生成 pre-master key，再通过 HKDF-Expand 生成 forward-secret key，即真正用来加密业务数据的密钥。&lt;/p&gt;
&lt;h1 id=&#34;cetv-tag&#34;&gt;CETV Tag&lt;/h1&gt;
&lt;p&gt;与 TLS 明文传输客户端证书不同，QUIC 的 client hello 中包含一个 CETV 标志，用于标记客户端证书、通道ID以及其他 hello 消息中的非公开数据。CETV 通过 AEAD 方式加密保护，所用密钥的生成方式与 forward-secret key 的生成方式类似。由于 client hello 只有一次，所以 AEAD 加密时使用的 nonce 可以是 0。&lt;/p&gt;
&lt;h1 id=&#34;证书压缩&#34;&gt;证书压缩&lt;/h1&gt;
&lt;p&gt;TLS 的证书链是按照源文件大小直接传递的，在握手阶段占大头。 QUIC 为了简化交互，将证书压缩后传输，并不传递CA根证书，而是在交互中包含本地缓存证书的摘要值，以确认双方是否共享同一证书链。&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit#heading=h.sx7u0bm1ucc0&#34;&gt;QUIC Crypto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.upyun.com/tech/article/571/QUIC%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%B9%8BInitial%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86.html&#34;&gt;QUIC协议详解之Initial包的处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-ietf-tls-tls13-28#appendix-A&#34;&gt;The Transport Layer Security (TLS) Protocol Version 1.3 draft-ietf-tls-tls13-28&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-ietf-quic-transport-27/#section-7&#34;&gt;QUIC: A UDP-Based Multiplexed and Secure Transport draft-ietf-quic-transport-27&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cryptologie.net/article/446/quic-crypto-and-simple-state-machines/&#34;&gt;QUIC Crypto and simple state machines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tls13.xargs.org/&#34;&gt;The Illustrated TLS 1.3 Connection&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于加密和密码学的经验教训和误解</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E5%92%8C%E8%AF%AF%E8%A7%A3/</link>
      <pubDate>Tue, 21 Dec 2021 15:25:18 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E5%92%8C%E8%AF%AF%E8%A7%A3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&#34;https://security.stackexchange.com/questions/2202/lessons-learned-and-misconceptions-regarding-encryption-and-cryptology&#34;&gt;stackexchange&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;密码学是一个广泛复杂的主题，即使经验丰富的工程师在初步应用密码技术时也会犯错，而加密又是一个重要的行为，在这件事上犯错的代价往往是巨大的。因此本文旨在记录常见的密码应用误区、经验教训以及对于算法或API的谨慎选择。&lt;/p&gt;
&lt;h2 id=&#34;不要创造算法&#34;&gt;不要创造算法&lt;/h2&gt;
&lt;p&gt;不要发明自己的加密算法或协议，因为容易出错。加密算法很复杂，需要大量的严谨的审查以确保其安全性，通常自己发明的算法或协议，无法提供合理的数学推导以证明其安全。&lt;/p&gt;
&lt;p&gt;最佳选择是，使用标准加密算法和协议。通常一个标准算法的诞生，是为了解决曾经的某些问题，而这些问题很可能就是你所面临的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 TLS 或 SSL 解决通信安全&lt;/li&gt;
&lt;li&gt;使用 GPG 或 PGP 解决静态数据安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些属于经过充分验证的密码方案，如果需要使用密码接口实现某些功能，优先考虑使用一些高级加密库，例如 cryptlib、GPGME、Keyczar等，而不是诸如 OpenSSL、CryptoAPI、JCE 等易于出错且难以应用的低级别库。&lt;/p&gt;
&lt;h2 id=&#34;不要使用非认证的加密&#34;&gt;不要使用非认证的加密&lt;/h2&gt;
&lt;p&gt;这是一种非常常见的错误——&lt;strong&gt;对数据进行加密而不进行认证&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如：某开发者想保护敏感信息，使用 AES-CBC 模式对该消息进行加密。&lt;/p&gt;
&lt;p&gt;该行为仅实现了消息的机密性，但却无法保证在面临主动攻击（如篡改）、重返攻击和反射攻击等威胁时的安全性。&lt;/p&gt;
&lt;p&gt;而增加消息认证即可解决该问题。&lt;/p&gt;
&lt;p&gt;许多线上系统出现过该问题导致的严重漏洞，如 &lt;a href=&#34;http://netifera.com/research/poet/ieee-aspnetcrypto.pdf&#34;&gt;ASP.NET&lt;/a&gt;, &lt;a href=&#34;https://crypto.stackexchange.com/q/1066/351&#34;&gt;XML&lt;/a&gt; &lt;a href=&#34;https://crypto.stackexchange.com/q/1042/351&#34;&gt;encryption&lt;/a&gt;, &lt;a href=&#34;http://www.informationweek.com/news/security/vulnerabilities/231901532&#34;&gt;Amazon EC2&lt;/a&gt;, &lt;a href=&#34;http://usenix.org/events/woot10/tech/full_papers/Rizzo.pdf&#34;&gt;JavaServer Faces, Ruby on Rails, OWASP ESAPI&lt;/a&gt;, &lt;a href=&#34;http://www.cs.columbia.edu/~smb/papers/badesp.ps&#34;&gt;IPSEC&lt;/a&gt;, &lt;a href=&#34;http://www.cs.berkeley.edu/~daw/papers/wep-mob01.pdf&#34;&gt;WEP&lt;/a&gt;, &lt;a href=&#34;https://www.trustwave.com/spiderlabs/advisories/TWSL2010-001.txt&#34;&gt;ASP.NET again&lt;/a&gt;, 以及 &lt;a href=&#34;http://lasecwww.epfl.ch/pub/lasec/doc/Vau02a.ps&#34;&gt;SSH2&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;为了避免该问题，应该在每次加密时都使用消息认证，主流做法有以下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最简便的方式是，使用现成的加密认证方案，如 GCM、CWC、EAX、CCM、OCB，这些加密方法实现了加密的同时并对数据做认证，使用者无需再关心该问题；&lt;/li&gt;
&lt;li&gt;另一种方式是，自己实现消息认证。首先，使用适当的对称加密方法加密消息（例如AES-CBC），然后对密文数据生成消息认证码（如AES-CMAC, SHA1-HMAC, SHA256-HMAC），并在传输数据前，将生成的 MAC 摘要附在密文后。对于接收端，在解密数据前先验证 MAC 摘要的有效性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;不要将一个密钥同时用于加密认证或签名&#34;&gt;不要将一个密钥同时用于加密、认证或签名&lt;/h2&gt;
&lt;p&gt;一个密钥不用该重用于多种目的，这种行为会扩大风险。&lt;/p&gt;
&lt;p&gt;例如，如果你有一对 RSA 公私钥对，不应该将其既用于加密又用于签名。如果你需要加密和签名这两种行为，那么就生成两对密钥。&lt;/p&gt;
&lt;p&gt;相应的，对于对称加密而言，不应该将用于加密的密钥，用于生成消息认证码。总而言之，不要将密钥重用与不同的目的。&lt;/p&gt;
&lt;h2 id=&#34;对拼接字符串做哈希要慎重&#34;&gt;对拼接字符串做哈希要慎重&lt;/h2&gt;
&lt;p&gt;例如，某开发者想获取字符串 S 和 T 的哈希值。于是他将 S 与 T 做拼接后进行哈希运算，获得H(S||T)。这是有缺陷的。&lt;/p&gt;
&lt;p&gt;问题在于，拼接使得两个字符串的边界不明确。例如 &lt;code&gt;builtin&lt;/code&gt;||&lt;code&gt;securely&lt;/code&gt; = &lt;code&gt;built&lt;/code&gt;||&lt;code&gt;insecurely&lt;/code&gt;，哈希运算无法识别字符串 S 和 T。因此攻击者或许可以改变两个字符串的边界而不改变哈希值。例如，如果 Alice 想发送两个字符串 &lt;code&gt;builtin &lt;/code&gt;和&lt;code&gt;securely&lt;/code&gt;，攻击者可以在不使哈希值失效的情况下将字符串改为&lt;code&gt;built&lt;/code&gt;和&lt;code&gt;insecurely&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在对拼接字符串进行数字签名或消息认证码运算是也会有类似的问题。&lt;/p&gt;
&lt;p&gt;解决办法是，不进行明文拼接，而是使用可以明确解码的编码。例如，当想计算H(S||T)时，不妨改为H(length(S)||S||T)，这里length(S)是一个32位值，用以表示字符串 S 的长度；亦或者采取 H(H(S)||H(T))、H(H(S)||T) 等方式。&lt;/p&gt;
&lt;p&gt;有关该问题的相关案例参见 &lt;a href=&#34;http://rdist.root.org/2009/05/20/amazon-web-services-signature-vulnerability/&#34;&gt;this flaw in Amazon Web Services&lt;/a&gt;、 &lt;a href=&#34;http://netifera.com/research/flickr_api_signature_forgery.pdf&#34;&gt;this flaw in Flickr&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;不要重用nonces或ivs&#34;&gt;不要重用nonces或IVs&lt;/h2&gt;
&lt;p&gt;许多加密模式需要 IV（初始化向量）。永远不要重复使用同一个 IV，这样会导致严重的漏洞。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于流密码而言，例如 CTR 或 OFB 模式，会导致加密数据被轻松恢复为明文&lt;/li&gt;
&lt;li&gt;对于 CBC 等其它模式而言，重用 IV 同样会造成明文恢复攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此不管使用什么加密模式，都不应该重用 IV。&lt;/p&gt;
&lt;h2 id=&#34;确保随机数生成器具备足够的熵&#34;&gt;确保随机数生成器具备足够的熵&lt;/h2&gt;
&lt;p&gt;确保使用密码伪随机数生成器来产生key、IV、nonce等，而不是使用&lt;code&gt;rand()&lt;/code&gt;, &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;drand48()&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;确保给随机数生成器注入足够的熵，不要使用日期作为种子，这是可预测的。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;srand(time(NULL))&lt;/code&gt;并不好，比较好的方式是给随机数生成器注入128位数据或真随机数，例如通过&lt;code&gt;/dev/urandom&lt;/code&gt;, &lt;code&gt;CryptGenRandom&lt;/code&gt;或其它类似工具。在 Java 中，使用 SecureRandom 而不是 Random。在 .NET 中，使用 System.Security.Cryptography.RandomNumberGenerator，而不是 System.Random。在 Python 中，使用 random.SystemRandom，而不是 random。&lt;/p&gt;
&lt;h2 id=&#34;对于对称加密不要使用ecb模式&#34;&gt;对于对称加密，不要使用ECB模式&lt;/h2&gt;
&lt;p&gt;例如，一图片数据的明文显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/5/56/Tux.jpg&#34; alt=&#34;明文&#34;&gt;&lt;/p&gt;
&lt;p&gt;该数据经ECB模式加密后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/f/f0/Tux_ecb.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;该数据经CBC模式加密后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/a/a0/Tux_secure.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;避免使用密码作为密钥&#34;&gt;避免使用密码作为密钥&lt;/h2&gt;
&lt;p&gt;一个常见的错误做法是，使用密码或密码的哈希值作为加密密钥。密钥需要有足够的熵，而大多数密码/口令并不具备，因此容易遭到字典攻击。&lt;/p&gt;
&lt;p&gt;如果一定要基于密码来生成密钥，那么可以通过迭代哈希的方式，来增加字典攻击的难度，例如H(H(H(&amp;hellip;H(password)&amp;hellip;)))。&lt;/p&gt;
&lt;h2 id=&#34;不要使用不安全的密钥长度&#34;&gt;不要使用不安全的密钥长度&lt;/h2&gt;
&lt;p&gt;确保使用足够长的密钥，比如1024-bit 的 RSA 密钥在2010年左右已被证实不安全，建议使用至少 2048 长度的 RSA 密钥。&lt;/p&gt;
&lt;p&gt;对于对称密码而言，应使用 128-bit 以上的密钥。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>EncryptedSharedPreferences分析</title>
      <link>https://urchinzhou.com/post/encryptedsharedpreferences%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 06 Jul 2021 22:28:23 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/encryptedsharedpreferences%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;EncryptedSharedPreferenes 是 androidx 下安全组件中的加密类，实现&lt;code&gt;SharedPreferences&lt;/code&gt;的键值对加密。&lt;/p&gt;
&lt;p&gt;开发者文档中提供了&lt;code&gt;SharedPreferences&lt;/code&gt;加密键值对的实例代码，其中使用&lt;code&gt;MasterKeys&lt;/code&gt;来进行密钥管理，而在 &lt;a href=&#34;https://developer.android.com/reference/androidx/security/crypto/MasterKeys?hl=zh-cn&#34;&gt;MasterKeys&lt;/a&gt; 的文档中提示该类已废弃，应使用&lt;code&gt;MasterKey.Builder&lt;/code&gt;来管理主密钥（版本说明：基于 Jetpack Security 1.1.0-alpha01），示例如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;// this is equivalent to using deprecated MasterKeys.AES256_GCM_SPEC
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyGenParameterSpec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyGenParameterSpec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;MASTER_KEY_ALIAS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PURPOSE_ENCRYPT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PURPOSE_DECRYPT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setBlockModes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;BLOCK_MODE_GCM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setEncryptionPaddings&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ENCRYPTION_PADDING_NONE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setKeySize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KEY_SIZE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;MasterKey&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;masterKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MasterKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MainActivity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setKeyGenParameterSpec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;EncryptedSharedPreferences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;create&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;MainActivity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;s&#34;&gt;&amp;#34;your-app-preferences-name&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;masterKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// masterKey created above
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;EncryptedSharedPreferences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PrefKeyEncryptionScheme&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;AES256_SIV&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;EncryptedSharedPreferences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PrefValueEncryptionScheme&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;AES256_GCM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>关于xlog加密处理分析</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Exlog%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 06 Jul 2021 22:25:57 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Exlog%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;xlog 使用微型加密算法（TEA，Tiny Encryption Algorithm）对日志数据进行加密，使用 ECDH 密钥交换算法进行对称密钥的协商，对称密钥以数组形式存储在栈区，声明为 &lt;code&gt;LogCrypt&lt;/code&gt; 类的私有字段。&lt;/p&gt;
&lt;p&gt;会话密钥长度与椭圆曲线参数相关，xlog 中使用 16 Bytes 密钥。&lt;/p&gt;
&lt;h3 id=&#34;相关接口&#34;&gt;相关接口&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;uECC_make_key ( client_pubkey, client_pri )
&lt;ul&gt;
&lt;li&gt;生成客户端公私钥对&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;uECC_shared_secret ( svr_pubkey, client_pri, secret )
&lt;ul&gt;
&lt;li&gt;根据服务端公钥与客户端私钥，运算出对称密钥 secret&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;__TeaEncrypt ( log, secret )
&lt;ul&gt;
&lt;li&gt;使用对称密钥加密日志&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;协商流程&#34;&gt;协商流程：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;client&lt;/code&gt; 调用 &lt;code&gt;uECC_make_key&lt;/code&gt; 生成 pubKeyA 与 priKeyA；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server&lt;/code&gt; 调用 &lt;code&gt;uECC_make_key&lt;/code&gt; 生成 pubKeyB 与 priKeyB；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client&lt;/code&gt; 获取&lt;code&gt;server&lt;/code&gt; 公钥 &lt;code&gt;pubKeyB&lt;/code&gt; ，调用 &lt;code&gt;uECC_shared_secret&lt;/code&gt; 生成对称密钥 &lt;code&gt;secret&lt;/code&gt;；（此处采用 ECDH 密钥交换算法）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server&lt;/code&gt; 获取&lt;code&gt;client&lt;/code&gt; 公钥 &lt;code&gt;pubKeyA&lt;/code&gt; ，调用 &lt;code&gt;uECC_shared_secret&lt;/code&gt; 生成对称密钥 &lt;code&gt;secret&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>密码应用基础知识</title>
      <link>https://urchinzhou.com/post/%E5%AF%86%E7%A0%81%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 06 Jul 2021 22:25:17 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%AF%86%E7%A0%81%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h1 id=&#34;对称算法&#34;&gt;对称算法&lt;/h1&gt;
&lt;p&gt;加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密&lt;strong&gt;密钥是相同的&lt;/strong&gt;。这些算法也叫&lt;strong&gt;秘密密钥算法&lt;/strong&gt;或&lt;strong&gt;单密钥算法&lt;/strong&gt;，它要求发送者和接受者在安全通信之前，商定一个密钥。&lt;/p&gt;
&lt;p&gt;对称算法的安全性依赖于密钥，泄露密钥就意味着任何人都能对消息进行加密解密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对数据块运算，如果数据长度不够一块，则需要填充；加密之后数据长度可能会变长，某些场景下不适用；需要对数据进行缓存，某些场景下不适用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组算法的工作模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ECB 模式，最简单，加密长数据有风险；&lt;/li&gt;
&lt;li&gt;CBC 模式，&lt;strong&gt;最常用的工作模式&lt;/strong&gt;，但本身并没有什么优势，单纯因为过去用的人多，属于历史遗留问题；&lt;/li&gt;
&lt;li&gt;OFB 模式，效果类似于流密码，适合处理音视频数据；&lt;/li&gt;
&lt;li&gt;CFB 模式，效果类似于流密码，几乎没人用；&lt;/li&gt;
&lt;li&gt;CTR 模式，可并行加速，只要有条件就推荐使用，广泛应用于 ATM 网络安全和 IPSec 应用中；&lt;/li&gt;
&lt;li&gt;GCM、CCM 认证加密模式，既能加密又能防篡改防重放；&lt;/li&gt;
&lt;li&gt;XTS 存储加密模式，适合随机读写模式；&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>

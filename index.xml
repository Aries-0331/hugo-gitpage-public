<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aries blablabla</title>
    <link>https://urchinzhou.com/</link>
    <description>Recent content on Aries blablabla</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 21 Aug 2023 11:50:04 +0800</lastBuildDate><atom:link href="https://urchinzhou.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>推荐阅读</title>
      <link>https://urchinzhou.com/post/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</link>
      <pubDate>Mon, 21 Aug 2023 11:50:04 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</guid>
      <description>—— Paul Graham</description>
    </item>
    
    <item>
      <title>What happens when tcp listen to a port?</title>
      <link>https://urchinzhou.com/post/tcp/</link>
      <pubDate>Thu, 29 Jun 2023 18:24:09 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/tcp/</guid>
      <description>When reading the net/http code of golang, I was suddenly curious about the mechanism of tcp listen, then I googled and found this interesting Q&amp;amp;A - What happens when we say &amp;ldquo;listen to a port&amp;rdquo;? on StackOverflow.
Q:When we start a server application, we always need to speicify the port number it listens to. But how is this &amp;ldquo;listening mechanism&amp;rdquo; implemented under the hood?
My current imagination is like this:</description>
    </item>
    
    <item>
      <title>Go Basic - Interface as Parameter to Function</title>
      <link>https://urchinzhou.com/post/go-basic-interface-as-parameter-to-function/</link>
      <pubDate>Thu, 29 Jun 2023 17:50:27 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/go-basic-interface-as-parameter-to-function/</guid>
      <description>https://stackoverflow.com/questions/20314604/go-syntax-and-interface-as-parameter-to-function
Go uses interfaces for generalization of types. So if you want a function that takes a specific interface you write
1 func MyFunction(t SomeInterface) {...} Every type that satisfies SomeInterface can be passed to MyFunction.
Now, SomeInterface can look like this:
1 2 3 type SomeInterface interface { SomeFunction() } To satisfy SomeInterface, the type implementing it must implement SomeFunction().
If you, however, require an empty interface (interface{}) the object does not need to implement any method to be passed to the function:</description>
    </item>
    
    <item>
      <title>Go Package - gorm</title>
      <link>https://urchinzhou.com/post/go-package-gorm/</link>
      <pubDate>Wed, 28 Jun 2023 22:15:12 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/go-package-gorm/</guid>
      <description>GORM is a popular Object-Relational Mapping (ORM) package for Go, designed to simplify database operations and improve developer productivity. It provides a robust and expressive API for interacting with various databases, including PostgreSQL, MySQL, SQLite, and more. With GORM, you can focus on your application&amp;rsquo;s logic while it handles the complexities of database management.
Main Usage of GORM:
Model Definition: GORM allows you to define models, which are Go structs representing database tables.</description>
    </item>
    
    <item>
      <title>Go Package - gorilla mux</title>
      <link>https://urchinzhou.com/post/go-package-gorilla-mux/</link>
      <pubDate>Tue, 27 Jun 2023 17:00:03 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/go-package-gorilla-mux/</guid>
      <description>Gorilla/mux is a popular package in the Go ecosystem that simplifies routing and URL matching for HTTP services. It offers a rich set of features and allows developers to define custom routes, handle variables, and leverage middleware for enhanced functionality. With gorilla/mux, you can build scalable and maintainable web applications with ease.
Main Usage of gorilla/mux:
Routing: Gorilla/mux enables you to define powerful and dynamic routes by leveraging patterns, placeholders, and regular expressions.</description>
    </item>
    
    <item>
      <title>VSCode 安装 Go 相关工具失败</title>
      <link>https://urchinzhou.com/post/vs-code-%E5%AE%89%E8%A3%85-go-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Mon, 26 Jun 2023 17:37:07 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/vs-code-%E5%AE%89%E8%A3%85-go-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%A4%B1%E8%B4%A5/</guid>
      <description>1 go version go1.19.5 windows/amd64 使用 VS Code 安装 Go 插件后，安装关联工具时，输出内容报如下内容，或错误信息中包含类似 unresponse、timeout 等网络问题相关字</description>
    </item>
    
    <item>
      <title>A Glance at JavaScript</title>
      <link>https://urchinzhou.com/post/a-glance-at-javascript/</link>
      <pubDate>Sat, 24 Jun 2023 10:53:48 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/a-glance-at-javascript/</guid>
      <description>Introduction: Welcome, esteemed senior engineers, to the realm of JavaScript! As experts in object-oriented languages like C++, you are well-positioned to explore the unique features and possibilities that JavaScript offers. In this blog, we will delve into JavaScript&amp;rsquo;s language features, grammar, application scenarios, and provide insights on becoming a professional JavaScript developer.
JavaScript Language Features: Discover the dynamic nature of JavaScript and its powerful capabilities. Learn about JavaScript&amp;rsquo;s prototypal inheritance model, functional programming concepts, lexical scoping, closures, and the event-driven nature of the language.</description>
    </item>
    
    <item>
      <title>Mastering ChatGPT：Crafting Effective Prompt</title>
      <link>https://urchinzhou.com/post/mastering-chatgptcrafting-effective-prompt/</link>
      <pubDate>Fri, 23 Jun 2023 21:59:23 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/mastering-chatgptcrafting-effective-prompt/</guid>
      <description>Introduction: Engaging in conversations with AI models like ChatGPT can be an exciting and rewarding experience. However, achieving meaningful and accurate responses relies heavily on the quality of prompts provided. In this blog post, we will explore strategies for crafting excellent prompts that maximize the potential of ChatGPT and enhance the overall conversation. Let&amp;rsquo;s dive in and unlock the power of effective prompts!
Be Clear and Specific: Clearly communicate your intention and provide specific context in your prompts.</description>
    </item>
    
    <item>
      <title>HTML Introduction</title>
      <link>https://urchinzhou.com/post/html-introduction/</link>
      <pubDate>Wed, 21 Jun 2023 18:00:12 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/html-introduction/</guid>
      <description>This blog is an attempt to generate with ai.
In this blog post, we will embark on a journey into the world of web technology and explore the fundamental aspects of HTML (Hypertext Markup Language). As a crucial language for structuring web content, HTML lays the groundwork for creating visually appealing and interactive websites. Let&amp;rsquo;s dive in!
HTML Essentials: HTML employs tags to define elements and organize information on web pages.</description>
    </item>
    
    <item>
      <title>在新环境中配置多 Git 仓库的 ssh 权限</title>
      <link>https://urchinzhou.com/post/%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgit%E4%BB%93%E5%BA%93%E7%9A%84ssh%E6%9D%83%E9%99%90/</link>
      <pubDate>Fri, 11 Nov 2022 16:21:12 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgit%E4%BB%93%E5%BA%93%E7%9A%84ssh%E6%9D%83%E9%99%90/</guid>
      <description>配置多个 Git 仓库的 ssh 权限 跳转至 ssh 配置路径，通常默认为 ~/.ssh 创建 ssh 密钥对，按照提示创建文件名（eg:repo1-deploy-key、repo2-d</description>
    </item>
    
    <item>
      <title>关于QUIC Crypto</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Equic-crypto/</link>
      <pubDate>Fri, 04 Nov 2022 17:13:59 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Equic-crypto/</guid>
      <description>&lt;h1 id=&#34;简要介绍&#34;&gt;简要介绍&lt;/h1&gt;
&lt;p&gt;QUIC（Quick UDP Internet Connections）是一种默认加密的互联网传输协议，旨在提供安全、快速的 HTTP 传输，以替代 TCP 和 TLS。Google QUIC 的默认加密协议是自家的 QUIC Crypto。&lt;/p&gt;
&lt;p&gt;QUIC 与 TCP 的根本不同在于默认提供安全传输的设计原则。最初的 QUIC 结合了 TCP 的三次握手以及 TLS 1.3 的握手，并将 TLS的记录层数据帧格式替换为 QUIC 自己的，同时保留了 TLS 的握手消息。这种做法既保证了连接总是经过认证和加密的，同时使得初始连接建立速度更快。TCP 和 TLS1.3 完成握手需要两轮交互，而 QUIC 握手仅需一轮，如果客户端缓存了服务端的配置信息，那么甚至无需握手。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://github.com/Aries-0331/pic/blob/master/http-request-over-tcp-tls@2x.png?raw=true&#34; width=&#34;600&#34;&gt;
&lt;img src=&#34;https://github.com/Aries-0331/pic/blob/master/http-request-over-quic@2x.png?raw=true&#34; width=&#34;600&#34;&gt;
&lt;/div&gt;
&lt;h1 id=&#34;协商成本对比&#34;&gt;协商成本对比&lt;/h1&gt;
&lt;h2 id=&#34;quic&#34;&gt;QUIC&lt;/h2&gt;
&lt;p&gt;QUIC 的服务端有一个使用私钥签名的&lt;code&gt;server config&lt;/code&gt;参数列表，包含常规参数、 DH 公钥、有效期等信息，由于这些数据都是静态的，所以一次签名后可以长期使用，不需要每次建立连接时都签名。&lt;/p&gt;
&lt;p&gt;通道密钥协商使用&lt;code&gt;Diffie-Hellman&lt;/code&gt;，DH 算法所需要的服务端参数在&lt;code&gt;server config&lt;/code&gt;中，客户端参数通过第一个握手消息传递至服务端。为了实现 0-RTT 握手而设计的静态 &lt;code&gt;server config&lt;/code&gt;，同时也带来了加密连接的前向安全问题 —— 只要服务端还保存有 &lt;code&gt;server config&lt;/code&gt;，那么一旦密钥泄露，之前使用该密钥加密的数据都是可破解的。&lt;/p&gt;
&lt;p&gt;因此 QUIC 提供了两级加密：来自客户端的初始数据使用&lt;code&gt;server config&lt;/code&gt;中的 DH 值加密，该值可持久化存储几天，服务端收到客户端的连接后，立即回复一个临时的 DH 值，并重新加密连接。&lt;/p&gt;
&lt;p&gt;虽然乍一看这种做法没有 TLS1.3 所实现的前向安全更完善，但实际上， TLS 在大规模部署时为了减少网络交互，通常会启用 &lt;code&gt;SessionTickets&lt;/code&gt;，而&lt;code&gt;SessionTickets&lt;/code&gt;同样会持久化存储，并被用于破解加密连接，&lt;code&gt;server config&lt;/code&gt;和&lt;code&gt;SessionTickets&lt;/code&gt;可以说是半斤八两，相较而言 QUIC 提供了临时密钥用于实际通信，反而稍强于 TLS 的做法。&lt;/p&gt;
&lt;p&gt;每个连接使用一个临时密钥，与所有连接共用一个临时密钥，在安全性上的差异可以忽略不计，而牺牲这点安全性差异所带来的复杂度打折是很可观的，所以不妨在较短的时间跨度内，将服务器的 DH 密钥复用至所有连接上。&lt;/p&gt;
&lt;h2 id=&#34;tls13&#34;&gt;TLS1.3&lt;/h2&gt;
&lt;p&gt;TLS1.3 的握手主要做三件事情：密钥交换、获取服务器参数、认证；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;密钥交换：该阶段共享生成密钥所需的材料，例如所属计算方式或命名组（ECDHE or DHE），选择密码参数，例如对称加密选项；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器参数：该阶段确认其它握手参数，例如是否需要基于数字证书的客户端认证；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;认证：该阶段对服务端进行认证，对客户端选择性认证，并对密钥进行校验以及握手信息的完整性校验；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TLS 的握手分两种：非前向安全握手和前向安全握手，其与 QUIC 的握手效率对比大概为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于非前向安全握手，客户端做一次公钥加密约34us，服务端做一次私钥解密约1100us；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于前向安全握手，客户端做一次公钥加密、一次DH运算、一次伪随机数运算，大约耗时230us，服务端做一次私钥解密、一次DH运算、一次伪随机数运算，大约耗时1300us；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QUIC 客户端做一次 DH 运算、两次随机数运算、一次公钥加密，约耗时 184us，服务端做两次随机数运算，约耗时100us；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出 QUIC 与 TLS 在协商阶段的成本差异主要是非对称加解密造成的，当然这里没有包含校验证书链等操作，因为两个协议都有，并且默认两种协议所选的密码算法与选项相同或处于统一性能等级，比如摘要都用SHA-256、DH 曲线都用 Curve25519，如果给 QUIC 选 ECDH P-256 而 TLS 选 Curve25519，那就是另一种结果了。&lt;/p&gt;
&lt;p&gt;另外，TLS 有会话恢复机制，而 QUIC 则需要由 C/S 两端各自维护 DH 结果的缓存，虽然没有在协议层面支持这一特性，但牺牲这一便利而带来了大约5倍的效率提升，还是不错的。&lt;/p&gt;
&lt;h1 id=&#34;quic-handshake&#34;&gt;QUIC handshake&lt;/h1&gt;
&lt;p&gt;QUIC 的协商过程可以简单总结出三个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;server config&lt;/code&gt;是一个包含服务端临时密钥的参数集，大概每几天更新一次；&lt;/li&gt;
&lt;li&gt;初次建立连接时的 client hello 其实就是个空的消息，目的就是从 server 获取包含最新 &lt;code&gt;server config&lt;/code&gt; 的REJ(ect)消息，获取到后会重新发起正式的 client hello；&lt;/li&gt;
&lt;li&gt;server hello 是包含临时密钥的加密消息；&lt;/li&gt;
&lt;/ul&gt;
&lt;div align=center&gt;
  &lt;img src=&#34;https://lh4.googleusercontent.com/DLKsceJfawl4pkbWeaTx69tgW97gG4TQ3BNWBPF3YgtqbkKhHmzgSyL7iajoAibBW9qRx7DcJiCwF2dGZngMFRI3pylhbttoRKZ6LLvQEJuvRepn8gOeya9FrfYd_PvVGRswL6uQCexAimZZdBuUwI5ttPH_mo-i2bVKQFxu9jMosswjo2e4FQvn0YHq&#34; width=500&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;首次连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现 0-RTT handshake，客户端需要获取&lt;code&gt;server config&lt;/code&gt;，因此首次连接的成本是 1-RTT。&lt;/p&gt;
&lt;p&gt;当客户端第一次建立连接时，在握手成功前，客户端会先发送一个不完整的 &lt;code&gt;hello message&lt;/code&gt;以获取服务期配置及其真实性证明，而服务端为了避免向任意未证实的端发送大量真实性证明，因此需要验证客户端身份，这一过程可能会有多次交互，不过这些是一次性的。&lt;/p&gt;
&lt;p&gt;客户端的&lt;code&gt;hello message&lt;/code&gt;中包含一些键值对，例如服务端域名、源地址token、可接受的认证类型、通用证书集合、缓存的证书等（部分是可选的），主要用来表明身份，在收到客户端的&lt;code&gt;hello message&lt;/code&gt;后，服务端将返回拒绝消息或&lt;code&gt;server hello&lt;/code&gt;。hello 表示握手成功，拒绝消息则会附带供客户端握手使用的一些信息。&lt;/p&gt;
&lt;p&gt;例如，若客户端没有携带源地址token，而服务端不想给未认证的IP源发送&lt;code&gt;server config&lt;/code&gt;，那么服务端会在拒绝消息中携带源地址token，以便客户端的下次握手校验能通过。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server config&lt;/code&gt;通过键值对描述服务端的一系列参数，包含 server config ID、密钥交换算法、认证加密算法、公钥列表、有效期、版本等。客户端收到&lt;code&gt;server config&lt;/code&gt;后，通过证书链和签名来进行认证，然后就可以发送不会失败的完整握手消息。完整的握手消息除了上述不完整的消息内容外，还包含客户端使用的 server config ID、认证加密算法、密钥家换算法、客户端随机数、服务端随机数、公钥等。&lt;/p&gt;
&lt;p&gt;发送完整的&lt;code&gt;hello message&lt;/code&gt;后，双方就共同拥有了一个非前向安全密钥（也可称为初始密钥），此时客户端就可以给服务端开始发送应用数据了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非首次连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端在首次连接后，会把&lt;code&gt;server config&lt;/code&gt;存下来，之后再发起连接时，可直接发送业务数据，以此来实现 0-RTT。&lt;/p&gt;
&lt;h1 id=&#34;tls13状态机&#34;&gt;TLS1.3状态机&lt;/h1&gt;
&lt;div align=center&gt;&lt;img src=&#34;https://cryptologie.net/upload/sm1.png&#34; width=800&gt;&lt;/div&gt;
&lt;p&gt;从握手的状态图可以很快做出判断，TLS 比 QUIC 复杂好多。TLS 是一个相对可靠、完善的协议，但同时由于版本迭代较多，大量历史遗留问题导致其架构、接口、用例非常复杂，如果不考虑历史包袱等兼容性问题，应该可以设计出更优雅的“TLS”。&lt;/p&gt;
&lt;h1 id=&#34;密钥派生&#34;&gt;密钥派生&lt;/h1&gt;
&lt;p&gt;QUIC 的密钥材料通过 HMAC-SHA256 密钥派生函数（HKDF）生成，HKDF 采用先提取再扩展的设计方式，先将输入的字符转换为固定长度的伪随机数，然后将其扩展成若干个伪随机密钥。在 QUIC 的实现中，密钥协商阶段生成的 DH 密钥便是 HKDF 的输入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HKDF-Extract&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用原始的密钥材料，派生出一个符合密码学强度的伪随机密钥。HKDF-Extract 的输入包含客户端、服务端的nonce以及密钥协商输出的密钥（pre-master key），HKDF-Extract 的输出是一个伪随机密钥，作为主密钥，长度 32 bytes（前提是使用 SHA-256 作为摘要算法）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HKDF-Expand&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 HKDF-Expand 提取出来的伪随机密钥，扩展出指定长度的密钥（同时保证随机性）。以 HKDF-Extract 生成的 pre-master key 和下列信息作为输入，以生成 forward-secret key：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QUIC key expansion&lt;/li&gt;
&lt;li&gt;连接的 GUID&lt;/li&gt;
&lt;li&gt;client hello message&lt;/li&gt;
&lt;li&gt;server config&lt;/li&gt;
&lt;li&gt;DER 编码证书&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结来看就是，client hello message 获取到 server config，并生成 dh key，以该 key 作为 HKDF-Extract 的输入，生成 pre-master key，再通过 HKDF-Expand 生成 forward-secret key，即真正用来加密业务数据的密钥。&lt;/p&gt;
&lt;h1 id=&#34;cetv-tag&#34;&gt;CETV Tag&lt;/h1&gt;
&lt;p&gt;与 TLS 明文传输客户端证书不同，QUIC 的 client hello 中包含一个 CETV 标志，用于标记客户端证书、通道ID以及其他 hello 消息中的非公开数据。CETV 通过 AEAD 方式加密保护，所用密钥的生成方式与 forward-secret key 的生成方式类似。由于 client hello 只有一次，所以 AEAD 加密时使用的 nonce 可以是 0。&lt;/p&gt;
&lt;h1 id=&#34;证书压缩&#34;&gt;证书压缩&lt;/h1&gt;
&lt;p&gt;TLS 的证书链是按照源文件大小直接传递的，在握手阶段占大头。 QUIC 为了简化交互，将证书压缩后传输，并不传递CA根证书，而是在交互中包含本地缓存证书的摘要值，以确认双方是否共享同一证书链。&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit#heading=h.sx7u0bm1ucc0&#34;&gt;QUIC Crypto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.upyun.com/tech/article/571/QUIC%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%B9%8BInitial%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86.html&#34;&gt;QUIC协议详解之Initial包的处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-ietf-tls-tls13-28#appendix-A&#34;&gt;The Transport Layer Security (TLS) Protocol Version 1.3 draft-ietf-tls-tls13-28&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-ietf-quic-transport-27/#section-7&#34;&gt;QUIC: A UDP-Based Multiplexed and Secure Transport draft-ietf-quic-transport-27&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cryptologie.net/article/446/quic-crypto-and-simple-state-machines/&#34;&gt;QUIC Crypto and simple state machines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tls13.xargs.org/&#34;&gt;The Illustrated TLS 1.3 Connection&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2021</title>
      <link>https://urchinzhou.com/post/2021/</link>
      <pubDate>Tue, 28 Dec 2021 14:24:52 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/2021/</guid>
      <description>结婚 首先要说的是，和女友恋爱668天后，于10月31日领证结婚了。 曾经一度认为自己在30岁前不会考虑结婚的事情，但是遇到一个知书达理善解人意</description>
    </item>
    
    <item>
      <title>How to learn new programming languages and frameworks quickly</title>
      <link>https://urchinzhou.com/post/how_to_learn_new_programming_languages_and_frameworks_quickly/</link>
      <pubDate>Tue, 21 Dec 2021 16:05:14 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/how_to_learn_new_programming_languages_and_frameworks_quickly/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;An excerpt from &lt;a href=&#34;https://www.quastor.org/p/how-whatsapp-scaled-to-1-billion&#34;&gt;how-whatsapp-scaled-to-1-billion&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://news.ycombinator.com/item?id=28017289&#34;&gt;This&lt;/a&gt; is an interesting discussion on Hacker News for a process to learn new things quickly.&lt;/p&gt;
&lt;p&gt;Here are some of the top answers summarized.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于加密和密码学的经验教训和误解</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E5%92%8C%E8%AF%AF%E8%A7%A3/</link>
      <pubDate>Tue, 21 Dec 2021 15:25:18 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E5%92%8C%E8%AF%AF%E8%A7%A3/</guid>
      <description>本文翻译自stackexchange 密码学是一个广泛复杂的主题，即使经验丰富的工程师在初步应用密码技术时也会犯错，而加密又是一个重要的行为，</description>
    </item>
    
    <item>
      <title>Git修改commit信息</title>
      <link>https://urchinzhou.com/post/git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Tue, 20 Jul 2021 15:19:14 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;修改用户名/邮箱&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1. git rebase -i &amp;#34;commit id&amp;#34; //commit id 选择目标 commit 上一次的 commit ID
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2. 修改 pick 为 edit 后，保存退出
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3. git commit --amend --author=&amp;#34;username &amp;lt;useremail&amp;gt;&amp;#34;//eg: git commit --amend --author=&amp;#34;hahaha &amp;lt;hahaha@gmail.com&amp;gt;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4. git rebase --continue
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ps:如果想修改第一次commit的信息，则步骤1中参数 commit id 改为 --root，即 git rebase -i --root
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>logcat日志读取流程分析</title>
      <link>https://urchinzhou.com/post/logcat%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 06 Jul 2021 22:30:30 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/logcat%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
      <description>logcat 通过读 /dev/socket/logd 套接字节点，以从 logd 进程中获取信息。 在 /logcat/logcat.cpp 的 __logcat 方法中调用 android_logger_list_read 1 2 3 4 5 6 7 8 9 10 11 static int __logcat(android_logcat_context_internal* context) { ...... while (!context-&amp;gt;stop &amp;amp;&amp;amp; (!context-&amp;gt;maxCount || (context-&amp;gt;printCount &amp;lt; context-&amp;gt;maxCount))) { struct log_msg log_msg; int ret = android_logger_list_read(logger_list, &amp;amp;log_msg); if (!ret) { logcat_panic(context,</description>
    </item>
    
    <item>
      <title>一个野指针</title>
      <link>https://urchinzhou.com/post/%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 06 Jul 2021 22:29:13 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E6%8C%87%E9%92%88/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//常见错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;该代码段，声明了一个名为 a 的指针变量，之后将 12 存储在 a 所指向的空间中。&lt;/p&gt;
&lt;p&gt;声明了变量 a，但未对其初始化，所以并不知道 a 所指向的具体位置，即数据 12 将存储于什么地方尚未可知。&lt;/p&gt;
&lt;p&gt;声明一个指向整型的指针，不会创建用于存储整型值的内存空间。&lt;/p&gt;
&lt;p&gt;对于该代码段可能造成的结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;报错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若 a 的初始值是非法地址，则赋值语句将会报错，从而终止程序。在 UNIX 系统上，这种错误通常为“段错误（segmentation fault）”、“段违例（segmentation violation）”或“内存错误（memory fault）”。&lt;strong&gt;提示程序在试图访问一个并未分配给程序的内存位置。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不报错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若 a 的初始值刚好是一个合法的地址，则该地址的原值被新的赋值语句所覆盖，虽然你并无意修改该地址的值。这种情况下导致的错误很难发现，因为引发错误的代码大概率与原本用于操作被修改值的代码毫不相干。因此，&lt;strong&gt;在对指针进行间接访问之前，务必确保指针变量已被初始化。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>EncryptedSharedPreferences分析</title>
      <link>https://urchinzhou.com/post/encryptedsharedpreferences%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 06 Jul 2021 22:28:23 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/encryptedsharedpreferences%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;EncryptedSharedPreferenes 是 androidx 下安全组件中的加密类，实现&lt;code&gt;SharedPreferences&lt;/code&gt;的键值对加密。&lt;/p&gt;
&lt;p&gt;开发者文档中提供了&lt;code&gt;SharedPreferences&lt;/code&gt;加密键值对的实例代码，其中使用&lt;code&gt;MasterKeys&lt;/code&gt;来进行密钥管理，而在 &lt;a href=&#34;https://developer.android.com/reference/androidx/security/crypto/MasterKeys?hl=zh-cn&#34;&gt;MasterKeys&lt;/a&gt; 的文档中提示该类已废弃，应使用&lt;code&gt;MasterKey.Builder&lt;/code&gt;来管理主密钥（版本说明：基于 Jetpack Security 1.1.0-alpha01），示例如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;// this is equivalent to using deprecated MasterKeys.AES256_GCM_SPEC
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyGenParameterSpec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyGenParameterSpec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;MASTER_KEY_ALIAS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PURPOSE_ENCRYPT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PURPOSE_DECRYPT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setBlockModes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;BLOCK_MODE_GCM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setEncryptionPaddings&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ENCRYPTION_PADDING_NONE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setKeySize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KEY_SIZE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;MasterKey&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;masterKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MasterKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MainActivity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setKeyGenParameterSpec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;EncryptedSharedPreferences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;create&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;MainActivity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;s&#34;&gt;&amp;#34;your-app-preferences-name&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;masterKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// masterKey created above
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;EncryptedSharedPreferences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PrefKeyEncryptionScheme&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;AES256_SIV&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;EncryptedSharedPreferences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PrefValueEncryptionScheme&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;AES256_GCM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>HTTPS与HTTP</title>
      <link>https://urchinzhou.com/post/https%E4%B8%8Ehttp/</link>
      <pubDate>Tue, 06 Jul 2021 22:28:02 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/https%E4%B8%8Ehttp/</guid>
      <description>概念上理清 HTTPS 与 HTTP 的区别。 在互联网协议套件中，将网络协议分为四层，从下至上依次为链路层-网络层-传输层-应用层，HTTP 属于应用层协议。中文名</description>
    </item>
    
    <item>
      <title>SQLCipher替代SQLite</title>
      <link>https://urchinzhou.com/post/sqlcipher%E6%9B%BF%E4%BB%A3sqlite/</link>
      <pubDate>Tue, 06 Jul 2021 22:27:48 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/sqlcipher%E6%9B%BF%E4%BB%A3sqlite/</guid>
      <description>&lt;p&gt;SQLCipher 是基于 SQLite 的安全扩展，加解密行为对应用层透明，可使用标准 SQLite API 执行数据库操作，移植简单，以页为单位进行加解密操作，效率高，开销比 SQLite 多 5% 左右。&lt;/p&gt;
&lt;h3 id=&#34;安全特性&#34;&gt;安全特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加密算法使用 AES-256 CBC模式；&lt;/li&gt;
&lt;li&gt;使用口令初始化数据库，实际加密密钥根据口令派生产生，相同口令派生出的密钥不同；&lt;/li&gt;
&lt;li&gt;以页为单位加解密，默认页大小 4096 Bytes，可调整优化；&lt;/li&gt;
&lt;li&gt;对每一页写的时候，文末会附带消息验证码，用于读取时校验；&lt;/li&gt;
&lt;li&gt;加密算法由 OpenSSL libcrypto 等开源库支持；&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>TCP与粘包问题</title>
      <link>https://urchinzhou.com/post/tcp%E4%B8%8E%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 06 Jul 2021 22:26:31 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/tcp%E4%B8%8E%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;&lt;strong&gt;TCP 没有粘包问题&lt;/strong&gt;。搜索引擎中列出的各种关于“TCP 粘包问题”的文章，所讲的其实是采用 TCP 传输数据的应用层协议设计不合理导致的粘包问题，并不是 TCP 的锅。&lt;/p&gt;
&lt;p&gt;TCP 是流协议，没有粘包这个概念。&lt;/p&gt;
&lt;p&gt;所谓粘包问题，是指发送方的多条消息在传输到接收方时，由于被拼接在一起而导致无法解析的情况。要解决这一问题，需要合理设计应用层协议，约定好消息边界，以便即使多条消息被拼接在一起，也能够按照协议找到消息边界从而正确解析。&lt;/p&gt;
&lt;p&gt;之所以很多人将粘包问题看作是 TCP 造成的，是因为“拼接”这一行为发生在 TCP 层。通过 TCP 发送和接收的数据，均为数据流格式。当应用层协议使用 TCP 协议传输数据时，TCP 协议很可能将应用层发送的消息分成多个包依次发送或将多条消息组合后发送，这就会出现接收方收到的一个数据段可能由多条消息组成，即粘包。&lt;/p&gt;
&lt;p&gt;而实际情况是，TCP 本就是基于字节流而不是消息包的协议，它保证的是字节流的次序到达，对于字节流的解析应该是由应用层协议来完成的，所以&lt;strong&gt;粘包问题，实际上描述的是“如何设计应用层协议”的问题&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于gcc编译时函数符号导出的问题</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Egcc%E7%BC%96%E8%AF%91%E6%97%B6%E5%87%BD%E6%95%B0%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 06 Jul 2021 22:26:17 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Egcc%E7%BC%96%E8%AF%91%E6%97%B6%E5%87%BD%E6%95%B0%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;背景：在 Android P liblog 模块中增加一个功能，涉及外部函数调用。如在 &lt;code&gt;A.c&lt;/code&gt; 中定义函数 &lt;code&gt;fun&lt;/code&gt;，在 &lt;code&gt;A.h&lt;/code&gt; 中声明函数 &lt;code&gt;fun&lt;/code&gt;，在 &lt;code&gt;B.c&lt;/code&gt; 中包含 &lt;code&gt;A.h&lt;/code&gt; 后调用 &lt;code&gt;fun&lt;/code&gt;，文件名、路径等均没有问题，但编译时会触发 &lt;code&gt;error:undefined reference to &lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;分析：函数显然是定义了的，提示未定义应该是出于某种原因未找到。后发现 &lt;code&gt;logprint.c&lt;/code&gt; 文件中部分函数带有前缀 &lt;code&gt;LIBLOG_ABI_PUBLIC&lt;/code&gt;，该宏定义为 &lt;code&gt;#define LIBLOG_ABI_PUBLIC __attribute__((visibility(&amp;quot;default&amp;quot;)))&lt;/code&gt;，作用是设置符号的可见性属性，查看 liblog 的 Android.bp 文件，发现编译选项设置为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;cflags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;-Werror&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;-fvisibility=hidden&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可见性属性会覆盖编译时通过 &lt;code&gt;-fvisibility&lt;/code&gt; 选项指定的值，&lt;code&gt;default&lt;/code&gt; 可见性属性会使符号在所有情况下都被输出，&lt;code&gt;hidden&lt;/code&gt; 可见性属性会隐藏相应的符号。&lt;/p&gt;
&lt;p&gt;结论：该模块在编译时，通过编译选项 &lt;code&gt;&amp;quot;-fvisibility=hidden&amp;quot;&lt;/code&gt; 将符号的默认可见性属性设置为不可见，因此，对于源文件中没有显示声明为可见的函数或变量，无法被共享库的其它文件访问，从而导致编译时触发 &lt;code&gt;error:undefined reference to &lt;/code&gt;，解决办法是将需要对外共享的函数、变量的可见性属性标识为 &lt;code&gt;default&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;参考阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://my.huhoo.net/archives/2010/03/post_52.html&#34;&gt;控制符号的可见性&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于xlog加密处理分析</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Exlog%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 06 Jul 2021 22:25:57 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Exlog%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;xlog 使用微型加密算法（TEA，Tiny Encryption Algorithm）对日志数据进行加密，使用 ECDH 密钥交换算法进行对称密钥的协商，对称密钥以数组形式存储在栈区，声明为 &lt;code&gt;LogCrypt&lt;/code&gt; 类的私有字段。&lt;/p&gt;
&lt;p&gt;会话密钥长度与椭圆曲线参数相关，xlog 中使用 16 Bytes 密钥。&lt;/p&gt;
&lt;h3 id=&#34;相关接口&#34;&gt;相关接口&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;uECC_make_key ( client_pubkey, client_pri )
&lt;ul&gt;
&lt;li&gt;生成客户端公私钥对&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;uECC_shared_secret ( svr_pubkey, client_pri, secret )
&lt;ul&gt;
&lt;li&gt;根据服务端公钥与客户端私钥，运算出对称密钥 secret&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;__TeaEncrypt ( log, secret )
&lt;ul&gt;
&lt;li&gt;使用对称密钥加密日志&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;协商流程&#34;&gt;协商流程：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;client&lt;/code&gt; 调用 &lt;code&gt;uECC_make_key&lt;/code&gt; 生成 pubKeyA 与 priKeyA；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server&lt;/code&gt; 调用 &lt;code&gt;uECC_make_key&lt;/code&gt; 生成 pubKeyB 与 priKeyB；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client&lt;/code&gt; 获取&lt;code&gt;server&lt;/code&gt; 公钥 &lt;code&gt;pubKeyB&lt;/code&gt; ，调用 &lt;code&gt;uECC_shared_secret&lt;/code&gt; 生成对称密钥 &lt;code&gt;secret&lt;/code&gt;；（此处采用 ECDH 密钥交换算法）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server&lt;/code&gt; 获取&lt;code&gt;client&lt;/code&gt; 公钥 &lt;code&gt;pubKeyA&lt;/code&gt; ，调用 &lt;code&gt;uECC_shared_secret&lt;/code&gt; 生成对称密钥 &lt;code&gt;secret&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>关于数据分片与分段</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E4%B8%8E%E5%88%86%E6%AE%B5/</link>
      <pubDate>Tue, 06 Jul 2021 22:25:41 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E4%B8%8E%E5%88%86%E6%AE%B5/</guid>
      <description>链路层要求数据帧的长度最大值为 1500 字节，该特性被称为 MTU，即最大传输单元。当 IP 层的数据报大于 MTU 时，IP 层就需要进行分片，就是把数据报分成若干</description>
    </item>
    
    <item>
      <title>密码应用基础知识</title>
      <link>https://urchinzhou.com/post/%E5%AF%86%E7%A0%81%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 06 Jul 2021 22:25:17 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%AF%86%E7%A0%81%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h1 id=&#34;对称算法&#34;&gt;对称算法&lt;/h1&gt;
&lt;p&gt;加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密&lt;strong&gt;密钥是相同的&lt;/strong&gt;。这些算法也叫&lt;strong&gt;秘密密钥算法&lt;/strong&gt;或&lt;strong&gt;单密钥算法&lt;/strong&gt;，它要求发送者和接受者在安全通信之前，商定一个密钥。&lt;/p&gt;
&lt;p&gt;对称算法的安全性依赖于密钥，泄露密钥就意味着任何人都能对消息进行加密解密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对数据块运算，如果数据长度不够一块，则需要填充；加密之后数据长度可能会变长，某些场景下不适用；需要对数据进行缓存，某些场景下不适用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组算法的工作模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ECB 模式，最简单，加密长数据有风险；&lt;/li&gt;
&lt;li&gt;CBC 模式，&lt;strong&gt;最常用的工作模式&lt;/strong&gt;，但本身并没有什么优势，单纯因为过去用的人多，属于历史遗留问题；&lt;/li&gt;
&lt;li&gt;OFB 模式，效果类似于流密码，适合处理音视频数据；&lt;/li&gt;
&lt;li&gt;CFB 模式，效果类似于流密码，几乎没人用；&lt;/li&gt;
&lt;li&gt;CTR 模式，可并行加速，只要有条件就推荐使用，广泛应用于 ATM 网络安全和 IPSec 应用中；&lt;/li&gt;
&lt;li&gt;GCM、CCM 认证加密模式，既能加密又能防篡改防重放；&lt;/li&gt;
&lt;li&gt;XTS 存储加密模式，适合随机读写模式；&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>TLS协议</title>
      <link>https://urchinzhou.com/post/tls%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Tue, 06 Jul 2021 22:24:45 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/tls%E5%8D%8F%E8%AE%AE/</guid>
      <description>&lt;h2 id=&#34;tls-协议的设计目标&#34;&gt;TLS 协议的设计目标&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;构建一个安全传输层（Transport Layer Security）&lt;/strong&gt;，在基于连接的传输层（如 TCP）之上提供密码学安全，包括&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;机密性，信息加密传输，无法被窃听&lt;/li&gt;
&lt;li&gt;完整性，信息一旦被篡改，通信双方可感知&lt;/li&gt;
&lt;li&gt;认证，通信双方防止身份被冒充&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>善用阅读技巧 检视阅读</title>
      <link>https://urchinzhou.com/post/%E5%96%84%E7%94%A8%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7-%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB/</link>
      <pubDate>Tue, 06 Jul 2021 22:24:19 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%96%84%E7%94%A8%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7-%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB/</guid>
      <description>&lt;p&gt;检视阅读（inspectional reading），强调在有限的时间内完成阅读。&lt;/p&gt;
&lt;p&gt;初次接触这一概念，是在莫提默·艾德勒所写的《如何阅读一本书》。作者从阅读技巧层面，将阅读划分为四个层次，检视阅读属于其中的第二层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层被称为&lt;strong&gt;基础阅读&lt;/strong&gt;（elementary reading），是指脱离文盲程度，能够从字面意义上完成阅读动作，基本上小学阶段即可达到这一层次。&lt;/li&gt;
&lt;li&gt;第三层被称为&lt;strong&gt;分析阅读&lt;/strong&gt;（analytical reading），相较前两层而言，更优质、更系统，摆脱了时间的限制，旨在追求抓住整本书的内容，直到彻底内化。&lt;/li&gt;
&lt;li&gt;第四层，也是最高层次的阅读，被称为&lt;strong&gt;主题阅读&lt;/strong&gt;（syntopical reading），此时的目标已经不再针对于一本书，而是围绕一个主题，开展调研式的阅读。与其称之为阅读，不如说是「研究」更为贴切。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检视阅读相较于基础阅读多了时间上的要求，比如「速读」「略读」等，都属于检视阅读的范畴，大部分成年人所采取的阅读技巧便是如此。但是掌握这一技巧的人，大多并不会充分利用这一技巧，包括我自己，在有意识地学习阅读技巧之前，对于自己所掌握并常用的技能，并没有很好地运用，从而导致阅读很低效。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何理解平均负载</title>
      <link>https://urchinzhou.com/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</link>
      <pubDate>Tue, 06 Jul 2021 22:05:40 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;平均负载不仅包括&lt;strong&gt;正在使用 CPU&lt;/strong&gt; 的进程，还包括&lt;strong&gt;等待 CPU&lt;/strong&gt; 和&lt;strong&gt;等待 I/O&lt;/strong&gt; 的进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;什么是平均负载&#34;&gt;什么是平均负载&lt;/h3&gt;
&lt;p&gt;通常我们使用 top 或 uptime 命令，来查看系统负载情况时，都会关注 load average 这一参数，但实际上你真的理解这一参数后三个数字的含义吗？相当一部分人将平均负载简单理解为单位时间内的 CPU 使用率，其实不然。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root@zwx-virtual-machine:/# uptime
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 11:06:40 up 1 day, 12 min,  1 user,  load average: 0.09, 0.04, 0.01
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;图中 load average 后的三个数字，依次是过去1分钟、5分钟、15分钟的平均负载（Load Average）。简单来说，它代表的是单位时间内，系统处于&lt;strong&gt;可运行状态&lt;/strong&gt;和&lt;strong&gt;不可中断状态&lt;/strong&gt;的平均进程数，也就是&lt;strong&gt;平均活跃进程数&lt;/strong&gt;，和 CPU 使用率并没有直接关系。&lt;/p&gt;
&lt;p&gt;所谓可运行状态的进程，是指正在使用 CPU 或正在等待 CPU 的进程，也就是使用 ps 命令看到的处于 R/Running/Runnable 状态的进程。&lt;/p&gt;
&lt;p&gt;不可中断的进程，是指正处于内核态关键流程中的进程，且这些流程是不可打断的，比如等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态进程。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>

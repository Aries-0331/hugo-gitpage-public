<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aries notebook</title>
    <link>https://urchinzhou.com/</link>
    <description>Recent content on Aries notebook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 03 Apr 2024 21:48:56 +0800</lastBuildDate>
    <atom:link href="https://urchinzhou.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Flex Shrink &amp; Flex Grow</title>
      <link>https://urchinzhou.com/post/flex-shrink--flex-grow/</link>
      <pubDate>Wed, 03 Apr 2024 21:48:56 +0800</pubDate>
      <guid>https://urchinzhou.com/post/flex-shrink--flex-grow/</guid>
      <description>flex-shrink flex-shrink 是 CSS Flexbox 布局中的一个属性，它定义了当父容器的空间不足以容纳所有子项时，子项（flex项）如何收缩。简而言之，flex-shrink 控制了f</description>
    </item>
    <item>
      <title>Object.is in JavaScript</title>
      <link>https://urchinzhou.com/post/object.is-in-javascript/</link>
      <pubDate>Wed, 03 Apr 2024 17:56:05 +0800</pubDate>
      <guid>https://urchinzhou.com/post/object.is-in-javascript/</guid>
      <description>Object.is is a method introduced in ECMAScript 2015 (ES6) that determines whether two values are the same value. It&amp;rsquo;s a more precise comparison than the traditional == (loose equality) or === (strict equality) operators in JavaScript. Object.is aims to provide an accurate comparison algorithm, particularly useful for distinguishing between values like +0 and -0, and for correctly identifying NaN values, which traditional comparisons cannot.&#xA;Syntax 1 Object.is(value1, value2); value1: The first value to compare.</description>
    </item>
    <item>
      <title>React 设计模式</title>
      <link>https://urchinzhou.com/post/react%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 11 Jan 2024 14:55:46 +0800</pubDate>
      <guid>https://urchinzhou.com/post/react%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>常见的 React 设计模式： 1. 组件化 将UI拆分成独立、可复用的组件是React开发的核心。每个组件只负责一部分的UI呈现，保持组件的职责单一。 原子设计</description>
    </item>
    <item>
      <title>初步了解 SEO</title>
      <link>https://urchinzhou.com/post/seo/</link>
      <pubDate>Tue, 02 Jan 2024 14:44:13 +0800</pubDate>
      <guid>https://urchinzhou.com/post/seo/</guid>
      <description>搜索引擎优化（SEO）是一种提高网站在搜索引擎中的可见度的过程，使其更有可能吸引潜在客户和访问者。SEO主要关注提升网站在非付费搜索结果中的</description>
    </item>
    <item>
      <title>React 防止组件重新渲染</title>
      <link>https://urchinzhou.com/post/react-%E9%98%B2%E6%AD%A2%E7%BB%84%E4%BB%B6%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Wed, 03 May 2023 18:33:42 +0800</pubDate>
      <guid>https://urchinzhou.com/post/react-%E9%98%B2%E6%AD%A2%E7%BB%84%E4%BB%B6%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93/</guid>
      <description>在React中，组件的重新渲染通常由状态（state）或属性（props）的变化触发。虽然React通过虚拟DOM和高效的对比算法（diff</description>
    </item>
    <item>
      <title>SVG 与 Canvas</title>
      <link>https://urchinzhou.com/post/svg-%E4%B8%8E-canvas/</link>
      <pubDate>Wed, 29 Mar 2023 14:38:32 +0800</pubDate>
      <guid>https://urchinzhou.com/post/svg-%E4%B8%8E-canvas/</guid>
      <description>SVG（Scalable Vector Graphics）和Canvas是两种主要的 Web 技术，用于在网页上绘制图形，但它们在使用方式、性能和适用场景上有所不</description>
    </item>
    <item>
      <title>前端性能优化常用策略</title>
      <link>https://urchinzhou.com/post/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/</link>
      <pubDate>Sat, 25 Mar 2023 10:48:29 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/</guid>
      <description>最佳实践： 资源压缩和合并：使用工具（如Webpack）压缩JavaScript、CSS和图片文件，减少文件大小，提高加载速度。合并资源减少H</description>
    </item>
    <item>
      <title>Go Package - gorm</title>
      <link>https://urchinzhou.com/post/go-package---gorm/</link>
      <pubDate>Sun, 12 Mar 2023 22:15:12 +0800</pubDate>
      <guid>https://urchinzhou.com/post/go-package---gorm/</guid>
      <description>GORM is a popular Object-Relational Mapping (ORM) package for Go, designed to simplify database operations and improve developer productivity. It provides a robust and expressive API for interacting with various databases, including PostgreSQL, MySQL, SQLite, and more. With GORM, you can focus on your application&amp;rsquo;s logic while it handles the complexities of database management.&#xA;Main Usage of GORM:&#xA;Model Definition: GORM allows you to define models, which are Go structs representing database tables.</description>
    </item>
    <item>
      <title>Go Basic - Interface as Parameter to Function</title>
      <link>https://urchinzhou.com/post/go-basic---interface-as-parameter-to-function/</link>
      <pubDate>Wed, 01 Mar 2023 17:50:27 +0800</pubDate>
      <guid>https://urchinzhou.com/post/go-basic---interface-as-parameter-to-function/</guid>
      <description>https://stackoverflow.com/questions/20314604/go-syntax-and-interface-as-parameter-to-function&#xA;Go uses interfaces for generalization of types. So if you want a function that takes a specific interface you write&#xA;1 func MyFunction(t SomeInterface) {...} Every type that satisfies SomeInterface can be passed to MyFunction.&#xA;Now, SomeInterface can look like this:&#xA;1 2 3 type SomeInterface interface { SomeFunction() } To satisfy SomeInterface, the type implementing it must implement SomeFunction().&#xA;If you, however, require an empty interface (interface{}) the object does not need to implement any method to be passed to the function:</description>
    </item>
    <item>
      <title>Go Package - gorilla mux</title>
      <link>https://urchinzhou.com/post/go-package---gorilla-mux/</link>
      <pubDate>Wed, 22 Feb 2023 17:00:03 +0800</pubDate>
      <guid>https://urchinzhou.com/post/go-package---gorilla-mux/</guid>
      <description>Gorilla/mux is a popular package in the Go ecosystem that simplifies routing and URL matching for HTTP services. It offers a rich set of features and allows developers to define custom routes, handle variables, and leverage middleware for enhanced functionality. With gorilla/mux, you can build scalable and maintainable web applications with ease.&#xA;Main Usage of gorilla/mux:&#xA;Routing: Gorilla/mux enables you to define powerful and dynamic routes by leveraging patterns, placeholders, and regular expressions.</description>
    </item>
    <item>
      <title>VSCode 安装 Go 相关工具失败</title>
      <link>https://urchinzhou.com/post/vs-code-%E5%AE%89%E8%A3%85-go-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Tue, 07 Feb 2023 17:37:07 +0800</pubDate>
      <guid>https://urchinzhou.com/post/vs-code-%E5%AE%89%E8%A3%85-go-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%A4%B1%E8%B4%A5/</guid>
      <description>1 go version go1.19.5 windows/amd64 使用 VS Code 安装 Go 插件后，安装关联工具时，输出内容报如下内容，或错误信息中包含类似 unresponse、timeout 等网络问题相关字</description>
    </item>
    <item>
      <title>Mastering ChatGPT：Crafting Effective Prompt</title>
      <link>https://urchinzhou.com/post/mastering-chatgptcrafting-effective-prompt/</link>
      <pubDate>Mon, 23 Jan 2023 21:59:23 +0800</pubDate>
      <guid>https://urchinzhou.com/post/mastering-chatgptcrafting-effective-prompt/</guid>
      <description>Introduction: Engaging in conversations with AI models like ChatGPT can be an exciting and rewarding experience. However, achieving meaningful and accurate responses relies heavily on the quality of prompts provided. In this blog post, we will explore strategies for crafting excellent prompts that maximize the potential of ChatGPT and enhance the overall conversation. Let&amp;rsquo;s dive in and unlock the power of effective prompts!&#xA;Be Clear and Specific: Clearly communicate your intention and provide specific context in your prompts.</description>
    </item>
    <item>
      <title>React 状态管理常用策略</title>
      <link>https://urchinzhou.com/post/react-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/</link>
      <pubDate>Mon, 09 Jan 2023 12:01:36 +0800</pubDate>
      <guid>https://urchinzhou.com/post/react-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/</guid>
      <description>在 React 中，状态（State）是组件内部的数据结构，用于记录从挂载到卸载期间，可能会发生变化的数据。状态的更新会触发组件的重新渲染，因此合理地管</description>
    </item>
    <item>
      <title>JavaScript 模板</title>
      <link>https://urchinzhou.com/post/javascript-%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Fri, 30 Dec 2022 11:06:43 +0800</pubDate>
      <guid>https://urchinzhou.com/post/javascript-%E6%A8%A1%E6%9D%BF/</guid>
      <description>在JavaScript中，模板是指结合数据来生成 HTML 标记或其他文本的技术，模板通过声明式的标记语法允许你指定如何将对象属性插入到文档中。这种方</description>
    </item>
    <item>
      <title>JavsScript 原型链</title>
      <link>https://urchinzhou.com/post/javsscript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Mon, 24 Oct 2022 20:36:26 +0800</pubDate>
      <guid>https://urchinzhou.com/post/javsscript-%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>每个 JavaScript 对象都有一个指向其他对象的链接，这个链接就是我们所说的“原型”。当我们试图访问一个对象的属性或方法时，如果它自身没有这个属性或方法，J</description>
    </item>
    <item>
      <title>闭包</title>
      <link>https://urchinzhou.com/post/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Wed, 24 Aug 2022 13:13:04 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E9%97%AD%E5%8C%85/</guid>
      <description>初步理解闭包 接触 JavaScript 的闭包概念前，我在阅读部分前端项目代码时，下意识带着阅读 C++ 代码时的思维惯性来分析 JavaScript 代码，从而造成对一些变量的值，做出错误判</description>
    </item>
    <item>
      <title>关于QUIC Crypto</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Equic-crypto/</link>
      <pubDate>Mon, 04 Jul 2022 17:13:59 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Equic-crypto/</guid>
      <description>&lt;h1 id=&#34;简要介绍&#34;&gt;简要介绍&lt;/h1&gt;&#xA;&lt;p&gt;QUIC（Quick UDP Internet Connections）是一种默认加密的互联网传输协议，旨在提供安全、快速的 HTTP 传输，以替代 TCP 和 TLS。Google QUIC 的默认加密协议是自家的 QUIC Crypto。&lt;/p&gt;&#xA;&lt;p&gt;QUIC 与 TCP 的根本不同在于默认提供安全传输的设计原则。最初的 QUIC 结合了 TCP 的三次握手以及 TLS 1.3 的握手，并将 TLS 的记录层数据帧格式替换为 QUIC 自己的，同时保留了 TLS 的握手消息。这种做法既保证了连接总是经过认证和加密的，同时使得初始连接建立速度更快。TCP 和 TLS1.3 完成握手需要两轮交互，而 QUIC 握手仅需一轮，如果客户端缓存了服务端的配置信息，那么甚至无需握手。&lt;/p&gt;&#xA;&lt;div align=center&gt;&#xA;&lt;img src=&#34;https://github.com/Aries-0331/pic/blob/master/http-request-over-tcp-tls@2x.png?raw=true&#34; width=&#34;600&#34;&gt;&#xA;&lt;img src=&#34;https://github.com/Aries-0331/pic/blob/master/http-request-over-quic@2x.png?raw=true&#34; width=&#34;600&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h1 id=&#34;协商成本对比&#34;&gt;协商成本对比&lt;/h1&gt;&#xA;&lt;h2 id=&#34;quic&#34;&gt;QUIC&lt;/h2&gt;&#xA;&lt;p&gt;QUIC 的服务端有一个使用私钥签名的&lt;code&gt;server config&lt;/code&gt;参数列表，包含常规参数、 DH 公钥、有效期等信息，由于这些数据都是静态的，所以一次签名后可以长期使用，不需要每次建立连接时都签名。&lt;/p&gt;&#xA;&lt;p&gt;通道密钥协商使用&lt;code&gt;Diffie-Hellman&lt;/code&gt;，DH 算法所需要的服务端参数在&lt;code&gt;server config&lt;/code&gt;中，客户端参数通过第一个握手消息传递至服务端。为了实现 0-RTT 握手而设计的静态 &lt;code&gt;server config&lt;/code&gt;，同时也带来了加密连接的前向安全问题 —— 只要服务端还保存有 &lt;code&gt;server config&lt;/code&gt;，那么一旦密钥泄露，之前使用该密钥加密的数据都是可破解的。&lt;/p&gt;&#xA;&lt;p&gt;因此 QUIC 提供了两级加密：来自客户端的初始数据使用&lt;code&gt;server config&lt;/code&gt;中的 DH 值加密，该值可持久化存储几天，服务端收到客户端的连接后，立即回复一个临时的 DH 值，并重新加密连接。&lt;/p&gt;&#xA;&lt;p&gt;虽然乍一看这种做法没有 TLS1.3 所实现的前向安全更完善，但实际上， TLS 在大规模部署时为了减少网络交互，通常会启用 &lt;code&gt;SessionTickets&lt;/code&gt;，而&lt;code&gt;SessionTickets&lt;/code&gt;同样会持久化存储，并被用于破解加密连接，&lt;code&gt;server config&lt;/code&gt;和&lt;code&gt;SessionTickets&lt;/code&gt;可以说是半斤八两，相较而言 QUIC 提供了临时密钥用于实际通信，反而稍强于 TLS 的做法。&lt;/p&gt;&#xA;&lt;p&gt;每个连接使用一个临时密钥，与所有连接共用一个临时密钥，在安全性上的差异可以忽略不计，而牺牲这点安全性差异所带来的复杂度打折是很可观的，所以不妨在较短的时间跨度内，将服务器的 DH 密钥复用至所有连接上。&lt;/p&gt;&#xA;&lt;h2 id=&#34;tls13&#34;&gt;TLS1.3&lt;/h2&gt;&#xA;&lt;p&gt;TLS1.3 的握手主要做三件事情：密钥交换、获取服务器参数、认证；&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;密钥交换：该阶段共享生成密钥所需的材料，例如所属计算方式或命名组（ECDHE or DHE），选择密码参数，例如对称加密选项；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;服务器参数：该阶段确认其它握手参数，例如是否需要基于数字证书的客户端认证；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;认证：该阶段对服务端进行认证，对客户端选择性认证，并对密钥进行校验以及握手信息的完整性校验；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;TLS 的握手分两种：非前向安全握手和前向安全握手，其与 QUIC 的握手效率对比大概为：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于非前向安全握手，客户端做一次公钥加密约 34us，服务端做一次私钥解密约 1100us；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于前向安全握手，客户端做一次公钥加密、一次 DH 运算、一次伪随机数运算，大约耗时 230us，服务端做一次私钥解密、一次 DH 运算、一次伪随机数运算，大约耗时 1300us；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;QUIC 客户端做一次 DH 运算、两次随机数运算、一次公钥加密，约耗时 184us，服务端做两次随机数运算，约耗时 100us；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以看出 QUIC 与 TLS 在协商阶段的成本差异主要是非对称加解密造成的，当然这里没有包含校验证书链等操作，因为两个协议都有，并且默认两种协议所选的密码算法与选项相同或处于统一性能等级，比如摘要都用 SHA-256、DH 曲线都用 Curve25519，如果给 QUIC 选 ECDH P-256 而 TLS 选 Curve25519，那就是另一种结果了。&lt;/p&gt;&#xA;&lt;p&gt;另外，TLS 有会话恢复机制，而 QUIC 则需要由 C/S 两端各自维护 DH 结果的缓存，虽然没有在协议层面支持这一特性，但牺牲这一便利而带来了大约 5 倍的效率提升，还是不错的。&lt;/p&gt;&#xA;&lt;h1 id=&#34;quic-handshake&#34;&gt;QUIC handshake&lt;/h1&gt;&#xA;&lt;p&gt;QUIC 的协商过程可以简单总结出三个要点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;server config&lt;/code&gt;是一个包含服务端临时密钥的参数集，大概每几天更新一次；&lt;/li&gt;&#xA;&lt;li&gt;初次建立连接时的 client hello 其实就是个空的消息，目的就是从 server 获取包含最新 &lt;code&gt;server config&lt;/code&gt; 的 REJ(ect)消息，获取到后会重新发起正式的 client hello；&lt;/li&gt;&#xA;&lt;li&gt;server hello 是包含临时密钥的加密消息；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div align=center&gt;&#xA;  &lt;img src=&#34;https://lh4.googleusercontent.com/DLKsceJfawl4pkbWeaTx69tgW97gG4TQ3BNWBPF3YgtqbkKhHmzgSyL7iajoAibBW9qRx7DcJiCwF2dGZngMFRI3pylhbttoRKZ6LLvQEJuvRepn8gOeya9FrfYd_PvVGRswL6uQCexAimZZdBuUwI5ttPH_mo-i2bVKQFxu9jMosswjo2e4FQvn0YHq&#34; width=500&gt;&#xA;&lt;/div&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首次连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为了实现 0-RTT handshake，客户端需要获取&lt;code&gt;server config&lt;/code&gt;，因此首次连接的成本是 1-RTT。&lt;/p&gt;&#xA;&lt;p&gt;当客户端第一次建立连接时，在握手成功前，客户端会先发送一个不完整的 &lt;code&gt;hello message&lt;/code&gt;以获取服务期配置及其真实性证明，而服务端为了避免向任意未证实的端发送大量真实性证明，因此需要验证客户端身份，这一过程可能会有多次交互，不过这些是一次性的。&lt;/p&gt;&#xA;&lt;p&gt;客户端的&lt;code&gt;hello message&lt;/code&gt;中包含一些键值对，例如服务端域名、源地址 token、可接受的认证类型、通用证书集合、缓存的证书等（部分是可选的），主要用来表明身份，在收到客户端的&lt;code&gt;hello message&lt;/code&gt;后，服务端将返回拒绝消息或&lt;code&gt;server hello&lt;/code&gt;。hello 表示握手成功，拒绝消息则会附带供客户端握手使用的一些信息。&lt;/p&gt;&#xA;&lt;p&gt;例如，若客户端没有携带源地址 token，而服务端不想给未认证的 IP 源发送&lt;code&gt;server config&lt;/code&gt;，那么服务端会在拒绝消息中携带源地址 token，以便客户端的下次握手校验能通过。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;server config&lt;/code&gt;通过键值对描述服务端的一系列参数，包含 server config ID、密钥交换算法、认证加密算法、公钥列表、有效期、版本等。客户端收到&lt;code&gt;server config&lt;/code&gt;后，通过证书链和签名来进行认证，然后就可以发送不会失败的完整握手消息。完整的握手消息除了上述不完整的消息内容外，还包含客户端使用的 server config ID、认证加密算法、密钥家换算法、客户端随机数、服务端随机数、公钥等。&lt;/p&gt;&#xA;&lt;p&gt;发送完整的&lt;code&gt;hello message&lt;/code&gt;后，双方就共同拥有了一个非前向安全密钥（也可称为初始密钥），此时客户端就可以给服务端开始发送应用数据了。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非首次连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;客户端在首次连接后，会把&lt;code&gt;server config&lt;/code&gt;存下来，之后再发起连接时，可直接发送业务数据，以此来实现 0-RTT。&lt;/p&gt;&#xA;&lt;h1 id=&#34;tls13-状态机&#34;&gt;TLS1.3 状态机&lt;/h1&gt;&#xA;&lt;div align=center&gt;&lt;img src=&#34;https://cryptologie.net/upload/sm1.png&#34; width=800&gt;&lt;/div&gt;&#xA;&lt;p&gt;从握手的状态图可以很快做出判断，TLS 比 QUIC 复杂好多。TLS 是一个相对可靠、完善的协议，但同时由于版本迭代较多，大量历史遗留问题导致其架构、接口、用例非常复杂，如果不考虑历史包袱等兼容性问题，应该可以设计出更优雅的“TLS”。&lt;/p&gt;&#xA;&lt;h1 id=&#34;密钥派生&#34;&gt;密钥派生&lt;/h1&gt;&#xA;&lt;p&gt;QUIC 的密钥材料通过 HMAC-SHA256 密钥派生函数（HKDF）生成，HKDF 采用先提取再扩展的设计方式，先将输入的字符转换为固定长度的伪随机数，然后将其扩展成若干个伪随机密钥。在 QUIC 的实现中，密钥协商阶段生成的 DH 密钥便是 HKDF 的输入。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HKDF-Extract&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;使用原始的密钥材料，派生出一个符合密码学强度的伪随机密钥。HKDF-Extract 的输入包含客户端、服务端的 nonce 以及密钥协商输出的密钥（pre-master key），HKDF-Extract 的输出是一个伪随机密钥，作为主密钥，长度 32 bytes（前提是使用 SHA-256 作为摘要算法）。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HKDF-Expand&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;使用 HKDF-Expand 提取出来的伪随机密钥，扩展出指定长度的密钥（同时保证随机性）。以 HKDF-Extract 生成的 pre-master key 和下列信息作为输入，以生成 forward-secret key：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;QUIC key expansion&lt;/li&gt;&#xA;&lt;li&gt;连接的 GUID&lt;/li&gt;&#xA;&lt;li&gt;client hello message&lt;/li&gt;&#xA;&lt;li&gt;server config&lt;/li&gt;&#xA;&lt;li&gt;DER 编码证书&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;总结来看就是，client hello message 获取到 server config，并生成 dh key，以该 key 作为 HKDF-Extract 的输入，生成 pre-master key，再通过 HKDF-Expand 生成 forward-secret key，即真正用来加密业务数据的密钥。&lt;/p&gt;&#xA;&lt;h1 id=&#34;cetv-tag&#34;&gt;CETV Tag&lt;/h1&gt;&#xA;&lt;p&gt;与 TLS 明文传输客户端证书不同，QUIC 的 client hello 中包含一个 CETV 标志，用于标记客户端证书、通道 ID 以及其他 hello 消息中的非公开数据。CETV 通过 AEAD 方式加密保护，所用密钥的生成方式与 forward-secret key 的生成方式类似。由于 client hello 只有一次，所以 AEAD 加密时使用的 nonce 可以是 0。&lt;/p&gt;&#xA;&lt;h1 id=&#34;证书压缩&#34;&gt;证书压缩&lt;/h1&gt;&#xA;&lt;p&gt;TLS 的证书链是按照源文件大小直接传递的，在握手阶段占大头。 QUIC 为了简化交互，将证书压缩后传输，并不传递 CA 根证书，而是在交互中包含本地缓存证书的摘要值，以确认双方是否共享同一证书链。&lt;/p&gt;&#xA;&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit#heading=h.sx7u0bm1ucc0&#34;&gt;QUIC Crypto&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.upyun.com/tech/article/571/QUIC%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%B9%8BInitial%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86.html&#34;&gt;QUIC 协议详解之 Initial 包的处理&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-ietf-tls-tls13-28#appendix-A&#34;&gt;The Transport Layer Security (TLS) Protocol Version 1.3 draft-ietf-tls-tls13-28&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-ietf-quic-transport-27/#section-7&#34;&gt;QUIC: A UDP-Based Multiplexed and Secure Transport draft-ietf-quic-transport-27&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cryptologie.net/article/446/quic-crypto-and-simple-state-machines/&#34;&gt;QUIC Crypto and simple state machines&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://tls13.xargs.org/&#34;&gt;The Illustrated TLS 1.3 Connection&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>React Router</title>
      <link>https://urchinzhou.com/post/react-router/</link>
      <pubDate>Fri, 06 May 2022 14:31:14 +0800</pubDate>
      <guid>https://urchinzhou.com/post/react-router/</guid>
      <description>React Router 是一个用于React的路由库，它允许我们在React应用中实现客户端路由。这意味着用户可以在不重新加载页面的情况下导航到不同的URL，同</description>
    </item>
    <item>
      <title>JavsScript 高阶函数</title>
      <link>https://urchinzhou.com/post/javsscript-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 24 Apr 2022 21:14:54 +0800</pubDate>
      <guid>https://urchinzhou.com/post/javsscript-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</guid>
      <description>在 JavaScript 中，如果一个函数能接收一个或多个函数作为参数，或返回另一个函数，那么该函数被称为高阶函数。 高阶函数是函数式编程的一个重要概念，提供了极大</description>
    </item>
    <item>
      <title>懒加载</title>
      <link>https://urchinzhou.com/post/%E6%87%92%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Wed, 30 Mar 2022 10:09:28 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E6%87%92%E5%8A%A0%E8%BD%BD/</guid>
      <description>懒加载（Lazy Loading），也称为延迟加载，是 Web 开发中常用的优化技术。其基本原理是延迟加载页面上的资源（如图片、脚本、样式表等），直到</description>
    </item>
    <item>
      <title>Linux IPC</title>
      <link>https://urchinzhou.com/post/linux-ipc/</link>
      <pubDate>Wed, 23 Mar 2022 13:28:32 +0800</pubDate>
      <guid>https://urchinzhou.com/post/linux-ipc/</guid>
      <description>IPC（进程间通信），是 Linux 系统中不同进程间进行数据交换的机制。主要包括 管道（Pipe）：主要用于父子进程通信，分为匿名管道和命名管道（FIF</description>
    </item>
    <item>
      <title>JavsScript 箭头函数</title>
      <link>https://urchinzhou.com/post/javsscript-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 24 Jan 2022 21:40:30 +0800</pubDate>
      <guid>https://urchinzhou.com/post/javsscript-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</guid>
      <description>箭头函数 箭头函数是 ES6 (ECMAScript 2015) 引入的一个新增特性，提供了一种更简洁的方式来写函数表达式。它不仅语法简短，而且还有其他几个特别之处，特别是与this</description>
    </item>
    <item>
      <title>虚拟Dom</title>
      <link>https://urchinzhou.com/post/%E8%99%9A%E6%8B%9Fdom/</link>
      <pubDate>Fri, 07 Jan 2022 14:19:18 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E8%99%9A%E6%8B%9Fdom/</guid>
      <description>虚拟DOM（Virtual DOM）是一个编程概念，其中UI的表示形式保持在内存中，并通过某种库（如React）与“真实”的DOM（Docum</description>
    </item>
    <item>
      <title>2021</title>
      <link>https://urchinzhou.com/post/2021/</link>
      <pubDate>Sun, 02 Jan 2022 14:24:52 +0800</pubDate>
      <guid>https://urchinzhou.com/post/2021/</guid>
      <description>首先要说的是，和女友恋爱 668 天后，于 10 月 31 日领证结婚了。 曾经一度认为自己在 30 岁前不会考虑结婚的事情，但是遇到一个知书达理善解人意的伴侣，得果断</description>
    </item>
    <item>
      <title>JavsScript ES6</title>
      <link>https://urchinzhou.com/post/javsscript-es6/</link>
      <pubDate>Fri, 17 Dec 2021 21:30:48 +0800</pubDate>
      <guid>https://urchinzhou.com/post/javsscript-es6/</guid>
      <description>ES6（ECMAScript 2015 或 ECMAScript6）与 ES5 主要区别： 1. 变量声明 ES5: 只有 var 关键字用于变量声明，它有函数作用域或全局作用域。 ES6: 引</description>
    </item>
    <item>
      <title>Dom</title>
      <link>https://urchinzhou.com/post/dom/</link>
      <pubDate>Thu, 25 Nov 2021 14:14:09 +0800</pubDate>
      <guid>https://urchinzhou.com/post/dom/</guid>
      <description>DOM（文档对象模型 Document Object Model）是一个跨平台和语言独立的接口，允许程序和脚本动态地访问和更新文档的内容、结构和样式。DOM将HTML和X</description>
    </item>
    <item>
      <title>关于加密和密码学的经验教训和误解</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E5%92%8C%E8%AF%AF%E8%A7%A3/</link>
      <pubDate>Fri, 19 Nov 2021 15:25:18 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E5%92%8C%E8%AF%AF%E8%A7%A3/</guid>
      <description>本文译自stackexchange 密码学是一个广泛复杂的主题，即使经验丰富的工程师在初步应用密码技术时也会犯错，而加密又是一个重要的行为，在</description>
    </item>
    <item>
      <title>HTTPS与HTTP</title>
      <link>https://urchinzhou.com/post/https%E4%B8%8Ehttp/</link>
      <pubDate>Fri, 22 Oct 2021 22:28:02 +0800</pubDate>
      <guid>https://urchinzhou.com/post/https%E4%B8%8Ehttp/</guid>
      <description>概念上理清 HTTPS 与 HTTP 的区别。 在互联网协议套件中，将网络协议分为四层，从下至上依次为链路层-网络层-传输层-应用层，HTTP 属于应用层协议。中文名</description>
    </item>
    <item>
      <title>密码应用基础知识</title>
      <link>https://urchinzhou.com/post/%E5%AF%86%E7%A0%81%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sun, 12 Sep 2021 22:25:17 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E5%AF%86%E7%A0%81%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>对称算法 加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密密钥是相同的。这些算法也叫秘密密钥算法或单密钥算法，它要</description>
    </item>
    <item>
      <title>如何理解平均负载</title>
      <link>https://urchinzhou.com/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</link>
      <pubDate>Sun, 01 Aug 2021 22:05:40 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</guid>
      <description>平均负载不仅包括正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。 什么是平均负载 通常我们使用 top 或 uptime 命令，来查看系统负载情况时，都会关注 load average 这一参</description>
    </item>
    <item>
      <title>Git 修改 commit 信息</title>
      <link>https://urchinzhou.com/post/git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Tue, 20 Jul 2021 15:19:14 +0800</pubDate>
      <guid>https://urchinzhou.com/post/git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF/</guid>
      <description>修改用户名/邮箱 1 2 3 4 5 6 7 8 9 1. git rebase -i &amp;#34;commit id&amp;#34; //commit id 选择目标 commit 上一次的 commit ID 2. 修改 pick 为 edit 后，保存退出 3. git commit --amend --author=&amp;#34;username &amp;lt;useremail&amp;gt;&amp;#34;//eg: git commit --amend --author=&amp;#34;hahaha &amp;lt;hahaha@gmail.com&amp;gt;&amp;#34; 4. git rebase --continue ps:如果想修</description>
    </item>
    <item>
      <title>SQLCipher</title>
      <link>https://urchinzhou.com/post/sqlcipher%E6%9B%BF%E4%BB%A3sqlite/</link>
      <pubDate>Tue, 13 Jul 2021 22:27:48 +0800</pubDate>
      <guid>https://urchinzhou.com/post/sqlcipher%E6%9B%BF%E4%BB%A3sqlite/</guid>
      <description>SQLCipher 是基于 SQLite 的安全扩展，加解密行为对应用层透明，可使用标准 SQLite API 执行数据库操作，移植简单，以页为单位进行加解密操作，效率高，开销比 SQLite 多 5% 左右。 安</description>
    </item>
    <item>
      <title>EncryptedSharedPreferences分析</title>
      <link>https://urchinzhou.com/post/encryptedsharedpreferences%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 01 Jul 2021 22:28:23 +0800</pubDate>
      <guid>https://urchinzhou.com/post/encryptedsharedpreferences%E5%88%86%E6%9E%90/</guid>
      <description>EncryptedSharedPreferenes 是 androidx 下安全组件中的加密类，实现SharedPreferences的键值对加密。 开发者文档中提供了SharedPreferences加密键值</description>
    </item>
    <item>
      <title>logcat日志读取流程分析</title>
      <link>https://urchinzhou.com/post/logcat%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 17 Jun 2021 22:30:30 +0800</pubDate>
      <guid>https://urchinzhou.com/post/logcat%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
      <description>logcat 通过读 /dev/socket/logd 套接字节点，以从 logd 进程中获取信息。 在 /logcat/logcat.cpp 的 __logcat 方法中调用 android_logger_list_read 1 2 3 4 5 6 7 8 9 10 11 static int __logcat(android_logcat_context_internal* context) { ...... while (!context-&amp;gt;stop &amp;amp;&amp;amp; (!context-&amp;gt;maxCount || (context-&amp;gt;printCount &amp;lt; context-&amp;gt;maxCount))) { struct log_msg log_msg; int ret = android_logger_list_read(logger_list, &amp;amp;log_msg); if (!ret) { logcat_panic(context,</description>
    </item>
    <item>
      <title>关于xlog加密处理分析</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Exlog%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 28 May 2021 22:25:57 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Exlog%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>xlog 使用微型加密算法（TEA，Tiny Encryption Algorithm）对日志数据进行加密，使用 ECDH 密钥交换算法进行对称密钥的协商，对称密钥以数组形式存储在</description>
    </item>
    <item>
      <title>粘包问题</title>
      <link>https://urchinzhou.com/post/%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 22 May 2021 22:26:31 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>首先，粘包并不是 TCP 的问题。搜索引擎中列出的各种关于“TCP 粘包问题”的文章，所讲的其实是采用 TCP 传输数据的应用层协议设计不合理导致的粘包问题，</description>
    </item>
    <item>
      <title>关于数据分片与分段</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E4%B8%8E%E5%88%86%E6%AE%B5/</link>
      <pubDate>Tue, 27 Apr 2021 22:25:41 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E4%B8%8E%E5%88%86%E6%AE%B5/</guid>
      <description>链路层要求数据帧的长度最大值为 1500 字节，该特性被称为 MTU，即最大传输单元。当 IP 层的数据报大于 MTU 时，IP 层就需要进行分片，就是把数据报分成若干</description>
    </item>
    <item>
      <title>关于gcc编译时函数符号导出的问题</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Egcc%E7%BC%96%E8%AF%91%E6%97%B6%E5%87%BD%E6%95%B0%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 10 Apr 2021 22:26:17 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Egcc%E7%BC%96%E8%AF%91%E6%97%B6%E5%87%BD%E6%95%B0%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;背景：在 Android P liblog 模块中增加一个功能，涉及外部函数调用。如在 &lt;code&gt;A.c&lt;/code&gt; 中定义函数 &lt;code&gt;fun&lt;/code&gt;，在 &lt;code&gt;A.h&lt;/code&gt; 中声明函数 &lt;code&gt;fun&lt;/code&gt;，在 &lt;code&gt;B.c&lt;/code&gt; 中包含 &lt;code&gt;A.h&lt;/code&gt; 后调用 &lt;code&gt;fun&lt;/code&gt;，文件名、路径等均没有问题，但编译时会触发 &lt;code&gt;error:undefined reference to &lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;分析：函数显然是定义了的，提示未定义应该是出于某种原因未找到。后发现 &lt;code&gt;logprint.c&lt;/code&gt; 文件中部分函数带有前缀 &lt;code&gt;LIBLOG_ABI_PUBLIC&lt;/code&gt;，该宏定义为 &lt;code&gt;#define LIBLOG_ABI_PUBLIC __attribute__((visibility(&amp;quot;default&amp;quot;)))&lt;/code&gt;，作用是设置符号的可见性属性，查看 liblog 的 Android.bp 文件，发现编译选项设置为&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;cflags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;-Werror&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;-fvisibility=hidden&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;可见性属性会覆盖编译时通过 &lt;code&gt;-fvisibility&lt;/code&gt; 选项指定的值，&lt;code&gt;default&lt;/code&gt; 可见性属性会使符号在所有情况下都被输出，&lt;code&gt;hidden&lt;/code&gt; 可见性属性会隐藏相应的符号。&lt;/p&gt;&#xA;&lt;p&gt;结论：该模块在编译时，通过编译选项 &lt;code&gt;&amp;quot;-fvisibility=hidden&amp;quot;&lt;/code&gt; 将符号的默认可见性属性设置为不可见，因此，对于源文件中没有显示声明为可见的函数或变量，无法被共享库的其它文件访问，从而导致编译时触发 &lt;code&gt;error:undefined reference to &lt;/code&gt;，解决办法是将需要对外共享的函数、变量的可见性属性标识为 &lt;code&gt;default&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;参考阅读：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://my.huhoo.net/archives/2010/03/post_52.html&#34;&gt;控制符号的可见性&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>How to learn new programming languages and frameworks quickly</title>
      <link>https://urchinzhou.com/post/how_to_learn_new_programming_languages_and_frameworks_quickly/</link>
      <pubDate>Mon, 21 Dec 2020 16:05:14 +0800</pubDate>
      <guid>https://urchinzhou.com/post/how_to_learn_new_programming_languages_and_frameworks_quickly/</guid>
      <description>An excerpt from how-whatsapp-scaled-to-1-billion&#xA;This is an interesting discussion on Hacker News for a process to learn new things quickly.&#xA;Here are some of the top answers summarized.&#xA;For a new programming language, there are a couple of standard things you should try to implement.&#xA;Write several programs where you&#xA;Read/write to a file Turn a structured object into JSON Parse JSON into an object A basic script that can be run from the CLI, parses flags/args, reads stdin Send a HTTP request Implement a very basic web server When you’re doing these exercises, do not copy/paste any code.</description>
    </item>
    <item>
      <title>在新环境中配置多 Git 仓库的 ssh 权限</title>
      <link>https://urchinzhou.com/post/%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgit%E4%BB%93%E5%BA%93%E7%9A%84ssh%E6%9D%83%E9%99%90/</link>
      <pubDate>Wed, 11 Nov 2020 16:21:12 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgit%E4%BB%93%E5%BA%93%E7%9A%84ssh%E6%9D%83%E9%99%90/</guid>
      <description>配置多个 Git 仓库的 ssh 权限 跳转至 ssh 配置路径，通常默认为 ~/.ssh 创建 ssh 密钥对，按照提示创建文件名（eg:repo1-deploy-key、repo2-d</description>
    </item>
    <item>
      <title>一个野指针</title>
      <link>https://urchinzhou.com/post/%E6%8C%87%E9%92%88/</link>
      <pubDate>Sun, 23 Aug 2020 22:29:13 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E6%8C%87%E9%92%88/</guid>
      <description>1 2 3 //常见错误 int *a; *a = 12; 该代码段，声明了一个名为 a 的指针变量，之后将 12 存储在 a 所指向的空间中。 声明了变量 a，但未对其初始化，所以并不知道</description>
    </item>
    <item>
      <title>What happens when tcp listen to a port?</title>
      <link>https://urchinzhou.com/post/tcp/</link>
      <pubDate>Mon, 29 Jun 2020 18:24:09 +0800</pubDate>
      <guid>https://urchinzhou.com/post/tcp/</guid>
      <description>When reading the net/http code of golang, I was suddenly curious about the mechanism of tcp listen, then I googled and found this interesting Q&amp;amp;A - What happens when we say &amp;ldquo;listen to a port&amp;rdquo;? on StackOverflow.&#xA;Q:When we start a server application, we always need to speicify the port number it listens to. But how is this &amp;ldquo;listening mechanism&amp;rdquo; implemented under the hood?&#xA;My current imagination is like this:</description>
    </item>
    <item>
      <title>React Components and Props</title>
      <link>https://urchinzhou.com/post/react-basic---components-and-props/</link>
      <pubDate>Wed, 05 Feb 2020 15:58:02 +0800</pubDate>
      <guid>https://urchinzhou.com/post/react-basic---components-and-props/</guid>
      <description>Components What is components? Components are one of the core concepts of React. They are the foundation upon which we build user interfaces(UI) - UI building blocks.&#xA;Taking traditional Web development as an example, HTML lets us create rich structured documents with its built-in set of tags like &amp;lt;h1&amp;gt; and &amp;lt;li&amp;gt;:&#xA;1 2 3 4 5 6 7 8 &amp;lt;article&amp;gt; &amp;lt;h1&amp;gt;My First Component&amp;lt;/h1&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;Components: UI Building Blocks&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Defining a Component&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Using a Component&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/article&amp;gt; This markup combined with CSS for style, and then JavaScript for interactivity, lies behind every sidebar, avatar, modal, dropdown &amp;ndash; every piece of UI we see on the Web.</description>
    </item>
    <item>
      <title>TLS</title>
      <link>https://urchinzhou.com/post/tls%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 02 Feb 2020 22:24:45 +0800</pubDate>
      <guid>https://urchinzhou.com/post/tls%E5%8D%8F%E8%AE%AE/</guid>
      <description>TLS 协议的设计目标 构建一个安全传输层（Transport Layer Security），在基于连接的传输层（如 TCP）之上提供密码学安全，包括 机密性，信</description>
    </item>
    <item>
      <title>善用阅读技巧 检视阅读</title>
      <link>https://urchinzhou.com/post/%E5%96%84%E7%94%A8%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7-%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB/</link>
      <pubDate>Mon, 06 Jan 2020 22:24:19 +0800</pubDate>
      <guid>https://urchinzhou.com/post/%E5%96%84%E7%94%A8%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7-%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB/</guid>
      <description>检视阅读（inspectional reading），强调在有限的时间内完成阅读。 初次接触这一概念，是在莫提默·艾德勒所写的《如何阅读一本书》</description>
    </item>
  </channel>
</rss>

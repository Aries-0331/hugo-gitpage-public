<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on urchinzhou</title>
    <link>https://urchinzhou.com/post/</link>
    <description>Recent content in Posts on urchinzhou</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 04 Nov 2022 17:13:59 +0800</lastBuildDate><atom:link href="https://urchinzhou.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于QUIC Crypto</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Equic-crypto/</link>
      <pubDate>Fri, 04 Nov 2022 17:13:59 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Equic-crypto/</guid>
      <description>&lt;h1 id=&#34;简要介绍&#34;&gt;简要介绍&lt;/h1&gt;
&lt;p&gt;QUIC（Quick UDP Internet Connections）是一种默认加密的互联网传输协议，旨在提供安全、快速的 HTTP 传输，以替代 TCP 和 TLS。Google QUIC 的默认加密协议是自家的 QUIC Crypto。&lt;/p&gt;
&lt;p&gt;QUIC 与 TCP 的根本不同在于默认提供安全传输的设计原则。最初的 QUIC 结合了 TCP 的三次握手以及 TLS 1.3 的握手，并将 TLS的记录层数据帧格式替换为 QUIC 自己的，同时保留了 TLS 的握手消息。这种做法既保证了连接总是经过认证和加密的，同时使得初始连接建立速度更快。TCP 和 TLS1.3 完成握手需要两轮交互，而 QUIC 握手仅需一轮，如果客户端缓存了服务端的配置信息，那么甚至无需握手。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://blog.cloudflare.com/content/images/2018/07/http-request-over-tcp-tls@2x.png&#34; width=&#34;600&#34;&gt;
&lt;img src=&#34;https://blog.cloudflare.com/content/images/2018/07/http-request-over-quic@2x.png&#34; width=&#34;600&#34;&gt;
&lt;/div&gt;
&lt;h1 id=&#34;协商成本对比&#34;&gt;协商成本对比&lt;/h1&gt;
&lt;h2 id=&#34;quic&#34;&gt;QUIC&lt;/h2&gt;
&lt;p&gt;QUIC 的服务端有一个使用私钥签名的&lt;code&gt;server config&lt;/code&gt;参数列表，包含常规参数、 DH 公钥、有效期等信息，由于这些数据都是静态的，所以一次签名后可以长期使用，不需要每次建立连接时都签名。&lt;/p&gt;
&lt;p&gt;通道密钥协商使用&lt;code&gt;Diffie-Hellman&lt;/code&gt;，DH 算法所需要的服务端参数在&lt;code&gt;server config&lt;/code&gt;中，客户端参数通过第一个握手消息传递至服务端。为了实现 0-RTT 握手而设计的静态 &lt;code&gt;server config&lt;/code&gt;，同时也带来了加密连接的前向安全问题 —— 只要服务端还保存有 &lt;code&gt;server config&lt;/code&gt;，那么一旦密钥泄露，之前使用该密钥加密的数据都是可破解的。&lt;/p&gt;
&lt;p&gt;因此 QUIC 提供了两级加密：来自客户端的初始数据使用&lt;code&gt;server config&lt;/code&gt;中的 DH 值加密，该值可持久化存储几天，服务端收到客户端的连接后，立即回复一个临时的 DH 值，并重新加密连接。&lt;/p&gt;
&lt;p&gt;虽然乍一看这种做法没有 TLS1.3 所实现的前向安全更完善，但实际上， TLS 在大规模部署时为了减少网络交互，通常会启用 &lt;code&gt;SessionTickets&lt;/code&gt;，而&lt;code&gt;SessionTickets&lt;/code&gt;同样会持久化存储，并被用于破解加密连接，&lt;code&gt;server config&lt;/code&gt;和&lt;code&gt;SessionTickets&lt;/code&gt;可以说是半斤八两，相较而言 QUIC 提供了临时密钥用于实际通信，反而稍强于 TLS 的做法。&lt;/p&gt;
&lt;p&gt;每个连接使用一个临时密钥，与所有连接共用一个临时密钥，在安全性上的差异可以忽略不计，而牺牲这点安全性差异所带来的复杂度打折是很可观的，所以不妨在较短的时间跨度内，将服务器的 DH 密钥复用至所有连接上。&lt;/p&gt;
&lt;h2 id=&#34;tls13&#34;&gt;TLS1.3&lt;/h2&gt;
&lt;p&gt;TLS1.3 的握手主要做三件事情：密钥交换、获取服务器参数、认证；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;密钥交换：该阶段共享生成密钥所需的材料，例如所属计算方式或命名组（ECDHE or DHE），选择密码参数，例如对称加密选项；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器参数：该阶段确认其它握手参数，例如是否需要基于数字证书的客户端认证；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;认证：该阶段对服务端进行认证，对客户端选择性认证，并对密钥进行校验以及握手信息的完整性校验；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TLS 的握手分两种：非前向安全握手和前向安全握手，其与 QUIC 的握手效率对比大概为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于非前向安全握手，客户端做一次公钥加密约34us，服务端做一次私钥解密约1100us；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于前向安全握手，客户端做一次公钥加密、一次DH运算、一次伪随机数运算，大约耗时230us，服务端做一次私钥解密、一次DH运算、一次伪随机数运算，大约耗时1300us；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QUIC 客户端做一次 DH 运算、两次随机数运算、一次公钥加密，约耗时 184us，服务端做两次随机数运算，约耗时100us；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出 QUIC 与 TLS 在协商阶段的成本差异主要是非对称加解密造成的，当然这里没有包含校验证书链等操作，因为两个协议都有，并且默认两种协议所选的密码算法与选项相同或处于统一性能等级，比如摘要都用SHA-256、DH 曲线都用 Curve25519，如果给 QUIC 选 ECDH P-256 而 TLS 选 Curve25519，那就是另一种结果了。&lt;/p&gt;
&lt;p&gt;另外，TLS 有会话恢复机制，而 QUIC 则需要由 C/S 两端各自维护 DH 结果的缓存，虽然没有在协议层面支持这一特性，但牺牲这一便利而带来了大约5倍的效率提升，还是不错的。&lt;/p&gt;
&lt;h1 id=&#34;quic-handshake&#34;&gt;QUIC handshake&lt;/h1&gt;
&lt;p&gt;QUIC 的协商过程可以简单总结出三个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;server config&lt;/code&gt;是一个包含服务端临时密钥的参数集，大概每几天更新一次；&lt;/li&gt;
&lt;li&gt;初次建立连接时的 client hello 其实就是个空的消息，目的就是从 server 获取包含最新 &lt;code&gt;server config&lt;/code&gt; 的REJ(ect)消息，获取到后会重新发起正式的 client hello；&lt;/li&gt;
&lt;li&gt;server hello 是包含临时密钥的加密消息；&lt;/li&gt;
&lt;/ul&gt;
&lt;div align=center&gt;
  &lt;img src=&#34;https://lh4.googleusercontent.com/DLKsceJfawl4pkbWeaTx69tgW97gG4TQ3BNWBPF3YgtqbkKhHmzgSyL7iajoAibBW9qRx7DcJiCwF2dGZngMFRI3pylhbttoRKZ6LLvQEJuvRepn8gOeya9FrfYd_PvVGRswL6uQCexAimZZdBuUwI5ttPH_mo-i2bVKQFxu9jMosswjo2e4FQvn0YHq&#34; width=500&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;首次连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现 0-RTT handshake，客户端需要获取&lt;code&gt;server config&lt;/code&gt;，因此首次连接的成本是 1-RTT。&lt;/p&gt;
&lt;p&gt;当客户端第一次建立连接时，在握手成功前，客户端会先发送一个不完整的 &lt;code&gt;hello message&lt;/code&gt;以获取服务期配置及其真实性证明，而服务端为了避免向任意未证实的端发送大量真实性证明，因此需要验证客户端身份，这一过程可能会有多次交互，不过这些是一次性的。&lt;/p&gt;
&lt;p&gt;客户端的&lt;code&gt;hello message&lt;/code&gt;中包含一些键值对，例如服务端域名、源地址token、可接受的认证类型、通用证书集合、缓存的证书等（部分是可选的），主要用来表明身份，在收到客户端的&lt;code&gt;hello message&lt;/code&gt;后，服务端将返回拒绝消息或&lt;code&gt;server hello&lt;/code&gt;。hello 表示握手成功，拒绝消息则会附带供客户端握手使用的一些信息。&lt;/p&gt;
&lt;p&gt;例如，若客户端没有携带源地址token，而服务端不想给未认证的IP源发送&lt;code&gt;server config&lt;/code&gt;，那么服务端会在拒绝消息中携带源地址token，以便客户端的下次握手校验能通过。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server config&lt;/code&gt;通过键值对描述服务端的一系列参数，包含 server config ID、密钥交换算法、认证加密算法、公钥列表、有效期、版本等。客户端收到&lt;code&gt;server config&lt;/code&gt;后，通过证书链和签名来进行认证，然后就可以发送不会失败的完整握手消息。完整的握手消息除了上述不完整的消息内容外，还包含客户端使用的 server config ID、认证加密算法、密钥家换算法、客户端随机数、服务端随机数、公钥等。&lt;/p&gt;
&lt;p&gt;发送完整的&lt;code&gt;hello message&lt;/code&gt;后，双方就共同拥有了一个非前向安全密钥（也可称为初始密钥），此时客户端就可以给服务端开始发送应用数据了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非首次连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端在首次连接后，会把&lt;code&gt;server config&lt;/code&gt;存下来，之后再发起连接时，可直接发送业务数据，以此来实现 0-RTT。&lt;/p&gt;
&lt;h1 id=&#34;tls13状态机&#34;&gt;TLS1.3状态机&lt;/h1&gt;
&lt;div align=center&gt;&lt;img src=&#34;https://cryptologie.net/upload/sm1.png&#34; width=800&gt;&lt;/div&gt;
&lt;p&gt;从握手的状态图可以很快做出判断，TLS 比 QUIC 复杂好多。TLS 是一个相对可靠、完善的协议，但同时由于版本迭代较多，大量历史遗留问题导致其架构、接口、用例非常复杂，如果不考虑历史包袱等兼容性问题，应该可以设计出更优雅的“TLS”。&lt;/p&gt;
&lt;h1 id=&#34;密钥派生&#34;&gt;密钥派生&lt;/h1&gt;
&lt;p&gt;QUIC 的密钥材料通过 HMAC-SHA256 密钥派生函数（HKDF）生成，HKDF 采用先提取再扩展的设计方式，先将输入的字符转换为固定长度的伪随机数，然后将其扩展成若干个伪随机密钥。在 QUIC 的实现中，密钥协商阶段生成的 DH 密钥便是 HKDF 的输入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HKDF-Extract&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用原始的密钥材料，派生出一个符合密码学强度的伪随机密钥。HKDF-Extract 的输入包含客户端、服务端的nonce以及密钥协商输出的密钥（pre-master key），HKDF-Extract 的输出是一个伪随机密钥，作为主密钥，长度 32 bytes（前提是使用 SHA-256 作为摘要算法）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HKDF-Expand&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 HKDF-Expand 提取出来的伪随机密钥，扩展出指定长度的密钥（同时保证随机性）。以 HKDF-Extract 生成的 pre-master key 和下列信息作为输入，以生成 forward-secret key：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QUIC key expansion&lt;/li&gt;
&lt;li&gt;连接的 GUID&lt;/li&gt;
&lt;li&gt;client hello message&lt;/li&gt;
&lt;li&gt;server config&lt;/li&gt;
&lt;li&gt;DER 编码证书&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结来看就是，client hello message 获取到 server config，并生成 dh key，以该 key 作为 HKDF-Extract 的输入，生成 pre-master key，再通过 HKDF-Expand 生成 forward-secret key，即真正用来加密业务数据的密钥。&lt;/p&gt;
&lt;h1 id=&#34;cetv-tag&#34;&gt;CETV Tag&lt;/h1&gt;
&lt;p&gt;与 TLS 明文传输客户端证书不同，QUIC 的 client hello 中包含一个 CETV 标志，用于标记客户端证书、通道ID以及其他 hello 消息中的非公开数据。CETV 通过 AEAD 方式加密保护，所用密钥的生成方式与 forward-secret key 的生成方式类似。由于 client hello 只有一次，所以 AEAD 加密时使用的 nonce 可以是 0。&lt;/p&gt;
&lt;h1 id=&#34;证书压缩&#34;&gt;证书压缩&lt;/h1&gt;
&lt;p&gt;TLS 的证书链是按照源文件大小直接传递的，在握手阶段占大头。 QUIC 为了简化交互，将证书压缩后传输，并不传递CA根证书，而是在交互中包含本地缓存证书的摘要值，以确认双方是否共享同一证书链。&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit#heading=h.sx7u0bm1ucc0&#34;&gt;QUIC Crypto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.upyun.com/tech/article/571/QUIC%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%B9%8BInitial%E5%8C%85%E7%9A%84%E5%A4%84%E7%90%86.html&#34;&gt;QUIC协议详解之Initial包的处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-ietf-tls-tls13-28#appendix-A&#34;&gt;The Transport Layer Security (TLS) Protocol Version 1.3 draft-ietf-tls-tls13-28&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-ietf-quic-transport-27/#section-7&#34;&gt;QUIC: A UDP-Based Multiplexed and Secure Transport draft-ietf-quic-transport-27&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cryptologie.net/article/446/quic-crypto-and-simple-state-machines/&#34;&gt;QUIC Crypto and simple state machines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tls13.xargs.org/&#34;&gt;The Illustrated TLS 1.3 Connection&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2021年·因吹斯汀</title>
      <link>https://urchinzhou.com/post/2021%E5%9B%A0%E5%90%B9%E6%96%AF%E6%B1%80/</link>
      <pubDate>Tue, 28 Dec 2021 14:24:52 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/2021%E5%9B%A0%E5%90%B9%E6%96%AF%E6%B1%80/</guid>
      <description>&lt;h2 id=&#34;结婚&#34;&gt;结婚&lt;/h2&gt;
&lt;p&gt;首先要说的是，和女友恋爱668天后，于10月31日领证结婚了。&lt;/p&gt;
&lt;p&gt;曾经一度认为自己在30岁前不会考虑结婚的事情，但是遇到一个知书达理善解人意的伴侣，还是得果断下手，正所谓顺其自然&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;值得一提的是，我们对于领证结婚这件事情，都挺平静的。既没有普天同庆的那种兴奋，也没有没想到我也有今天的那种难以名状的情绪，更多的是将这件事情视为旅途中的一个小里程碑，后面还有更多精彩值得期待&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;从民政局出来后就近找了个火锅店稍作庆祝，店名为“高兴火锅”。（疫情导致一切蜜月计划沦为空谈，口吐芬芳&amp;hellip;&amp;hellip;）&lt;/p&gt;
&lt;h2 id=&#34;养猫&#34;&gt;养猫&lt;/h2&gt;
&lt;p&gt;第二件事情，是家里新增了两位成员，Nikki 和可乐，两小只英短姐妹花，她们的父母分别是英短银渐层和美短虎斑。&lt;/p&gt;
&lt;p&gt;Nikki是妹妹，毛色较浅，灰白相间，银渐层属性max。可乐是姐姐，毛色较深，灰白相间，面相偏虎斑。&lt;/p&gt;
&lt;p&gt;领回家的时候一个月出头，尚未从猫妈那里 get 埋便便技能，只好由我来“言传身教”，所幸姐姐比较聪明，很快便学会了，而妹妹只会傻傻地扒拉猫砂盆，到现在6个月大了还是没有学会&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;Nikki和可乐的加入，给我们的家庭增加了无限的欢乐，平时即便什么都不做，但是看着她俩玩闹就满心欢喜，幸福感爆棚。&lt;/p&gt;
&lt;p&gt;队友本来是个对猫无感的人，甚至略有排斥，但事实证明，谁都逃不过真香定律&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;下图左边是Nikki，右边是可乐，ღ( ´･ᴗ･` )比心。&lt;/p&gt;
&lt;img src=&#34;https://github.com/Newbie2333/mydrawer/blob/master/nikkicola.jpeg?raw=true&#34; width=360 alt=&#34;nikki&amp;可乐&#34;/&gt;
&lt;h2 id=&#34;技术&#34;&gt;技术&lt;/h2&gt;
&lt;p&gt;今年投入到个人技术提升的精力较少，主要精力都投入在工作上，各种商密、涉密项目、业务架构梳理和方案设计，无穷尽的会议和方案review，很是费神。&lt;/p&gt;
&lt;p&gt;抱怨归抱怨，工作还是要做的。密码模块开发、安全方案设计、渗透测试、漏洞分析，这些事情都算在信息安全的范畴内，却又离散得很，到头来感觉哪儿哪儿都不精，还是需要选择一个方向，重点突破。&lt;/p&gt;
&lt;p&gt;另外，在研究方案的过程中，机缘巧合下读到了一些密码学相关的优质文章，受益匪浅。这里推荐一篇&lt;a href=&#34;https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/#%E5%85%AD--tls%E5%8D%8F%E8%AE%AE%E7%BB%99%E6%88%91%E4%BB%AC%E7%9A%84%E5%90%AF%E5%8F%91----%E7%8E%B0%E4%BB%A3%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1&#34;&gt;TLS协议分析 与 现代加密通信协议设计&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;文章本身清晰地介绍了 TLS 协议的结构和设计思想，很适合辅助梳理零碎的密码知识，其中关联的一些资源对于密码应用的提升也大有裨益。&lt;/p&gt;
&lt;p&gt;Ps：信息安全是个非常宽泛的主题，抛开运营管理等大的话题，单是技术方面就包含渗透、Web、Android、iOS、逆向、加解密等众多细分领域，想要触类旁通实在很难，毕竟每个方向都需要投入大量精力深入研究。&lt;/p&gt;
&lt;p&gt;哦对，还顺带磨炼了一下C++，造了造轮子。接下来业余时间打算学一些前后端的技术，目前主要考虑从 Python 和 Go 入手。本职工作还是以密码应用为主，渗透和漏洞等安全分支，保持关注即可，不打算投入过多精力。&lt;/p&gt;
&lt;h2 id=&#34;阅读&#34;&gt;阅读&lt;/h2&gt;
&lt;p&gt;最有趣的，&lt;a href=&#34;https://book.douban.com/subject/35234118/&#34;&gt;《世风日上》&lt;/a&gt;。这本书的内容堪称千奇百怪，涉及投资、心理、社会、人文、艺术、政治等&amp;hellip;&amp;hellip;包含着雪球创始人方三文和聪明投资者“聊”出来的智慧。内容是对话体，读来轻松，代入感强，充斥着各种观点，共识与冲突并存，很是有趣。&lt;/p&gt;
&lt;p&gt;最难读的，&lt;a href=&#34;https://book.douban.com/subject/26912767/&#34;&gt;《深入理解计算机系统》&lt;/a&gt;。毕竟是本大而全的大部头，比较难啃。更多是在有针对性地查阅博客，首推&lt;a href=&#34;https://coolshell.cn/&#34;&gt;酷壳&lt;/a&gt;以及&lt;a href=&#34;https://draveness.me/&#34;&gt;draveness&lt;/a&gt;，两位大佬的文章用赏心悦目来形容毫不为过，篇篇精品内容丰富，即便是读与工作中所用技术无关的文章，也会有所收获。&lt;/p&gt;
&lt;p&gt;最推荐的，&lt;a href=&#34;https://book.douban.com/subject/10828002/&#34;&gt;《游戏改变世界》&lt;/a&gt;，全面消除了我玩游戏后似有若无的”负罪感“，希望所有的家长都能读到这本书。&lt;/p&gt;
&lt;p&gt;另外，二刷了&lt;a href=&#34;https://book.douban.com/subject/2567698/&#34;&gt;《三体》&lt;/a&gt;，消灭人类暴政，世界属于三体。&lt;/p&gt;
&lt;h2 id=&#34;娱乐&#34;&gt;娱乐&lt;/h2&gt;
&lt;p&gt;今年玩的游戏稍微杂一些，手机PC主机游戏都有涉及。&lt;/p&gt;
&lt;p&gt;手游推荐一款塔防游戏，Kindom Rush，游戏质量很高，关卡难度设置恰到好处，从上手开始一直到通关，期间完全不想玩别的游戏&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;断断续续和队友玩了一阵子王者荣耀，不得不说这游戏比较考验心态，容易上头，适合浅尝辄止。&lt;/p&gt;
&lt;p&gt;重新玩起了剑三，这次是和现实中的两位好朋友，一起做做日常、打打竞技场，毕业后的联系频率直线下降，没想到通过游戏又能经常聚在一起，还是蛮开心的。&lt;/p&gt;
&lt;p&gt;周末和节假日之类比较有空闲的时候，会一起琢磨琢磨换不同的游戏玩，饥荒、求生之路、原神、地平线&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;近期又新增一项娱乐活动，白嫖 Epic :D&lt;/p&gt;
&lt;p&gt;另外，买了个健身环大冒险，主要目的是让队友能在家锻炼锻炼，这几天下班回家我也尝试了一下，强度还可以，感觉可以取代外出跑步和健身了。&lt;/p&gt;
&lt;p&gt;另外值得一提的是，羽毛球技术有显著进步，看视频和一对一训练起到了很大作用，还入手了一把天斧77，水平不够装备来凑&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;img src=&#34;https://github.com/Newbie2333/mydrawer/blob/master/TF77.jpeg?raw=true&#34; width=360/&gt;
&lt;h2 id=&#34;理财&#34;&gt;理财&lt;/h2&gt;
&lt;p&gt;中丐 :D&lt;/p&gt;
&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;
&lt;p&gt;除了工作上写的年度总结，这是第一次坐下来慢慢回顾过去一年个人经历的事情。&lt;/p&gt;
&lt;p&gt;回忆的过程中发现，能清晰记起的事情屈指可数，一年竟就这么过去了，但把这桩桩件件罗列开来后一琢磨，嚯，看起来做的事情似乎也不少，总归是没有荒废。&lt;/p&gt;
&lt;p&gt;ps：写完后以上内容后，没直接发，去刷了刷推友的年度总结，又翻看了一下长期关注的几个博主的更新，不得不感慨，和优秀的人比起来，自己这一年属实是荒废了-.-）&lt;/p&gt;
&lt;p&gt;写这篇总结的动力来源，是昨天翻看 &lt;a href=&#34;https://draveness.me/&#34;&gt;draveness(左大)&lt;/a&gt; 的博客时，重读他的 &lt;a href=&#34;https://draveness.me/2020-summary/&#34;&gt;2020年总结·渐入佳境&lt;/a&gt; ，深感震撼。&lt;/p&gt;
&lt;p&gt;我从未规划过甚至想过自己能够对他人、技术社区或者往大的说，对世界，带来什么样的影响，我也很少为自己做长短期的人生规划。一直以来抱着的，是随遇而安、顺其自然的心态，充其量是在学习的时候会排个计划，所谓胸无大志，指的就是我这种心态吧&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;而读了 draveness 的文章后，我觉得自己应该做出一些改变，变得更积极一点、有条理一点、也更热爱世界一点。&lt;/p&gt;
&lt;p&gt;直接定太高远的目标容易放弃，所以打算从写字和个人管理入手，先把长期搁置的博客维护下去，至于写纯粹的技术文章，还是同时记录生活琐事，就边写边看吧。个人管理方面，打算学习一下 OKR，尝试对自己的精力做个合理规划，定期回顾，不至于把日子过得稀里糊涂的。&lt;/p&gt;
&lt;p&gt;于是便有了这篇文章。不知道以后回过头来翻看的时候，会以什么样的心态来审视现在粗糙的文字，就预祝比现在更进一步吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>How to learn new programming languages and frameworks quickly</title>
      <link>https://urchinzhou.com/post/how_to_learn_new_programming_languages_and_frameworks_quickly/</link>
      <pubDate>Tue, 21 Dec 2021 16:05:14 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/how_to_learn_new_programming_languages_and_frameworks_quickly/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;An excerpt from &lt;a href=&#34;https://www.quastor.org/p/how-whatsapp-scaled-to-1-billion&#34;&gt;how-whatsapp-scaled-to-1-billion&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://news.ycombinator.com/item?id=28017289&#34;&gt;This&lt;/a&gt; is an interesting discussion on Hacker News for a process to learn new things quickly.&lt;/p&gt;
&lt;p&gt;Here are some of the top answers summarized.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于加密和密码学的经验教训和误解</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E5%92%8C%E8%AF%AF%E8%A7%A3/</link>
      <pubDate>Tue, 21 Dec 2021 15:25:18 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD%E5%92%8C%E8%AF%AF%E8%A7%A3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&#34;https://security.stackexchange.com/questions/2202/lessons-learned-and-misconceptions-regarding-encryption-and-cryptology&#34;&gt;stackexchange&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;密码学是一个广泛复杂的主题，即使经验丰富的工程师在初步应用密码技术时也会犯错，而加密又是一个重要的行为，在这件事上犯错的代价往往是巨大的。因此本文旨在记录常见的密码应用误区、经验教训以及对于算法或API的谨慎选择。&lt;/p&gt;
&lt;h2 id=&#34;不要创造算法&#34;&gt;不要创造算法&lt;/h2&gt;
&lt;p&gt;不要发明自己的加密算法或协议，因为容易出错。加密算法很复杂，需要大量的严谨的审查以确保其安全性，通常自己发明的算法或协议，无法提供合理的数学推导以证明其安全。&lt;/p&gt;
&lt;p&gt;最佳选择是，使用标准加密算法和协议。通常一个标准算法的诞生，是为了解决曾经的某些问题，而这些问题很可能就是你所面临的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 TLS 或 SSL 解决通信安全&lt;/li&gt;
&lt;li&gt;使用 GPG 或 PGP 解决静态数据安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些属于经过充分验证的密码方案，如果需要使用密码接口实现某些功能，优先考虑使用一些高级加密库，例如 cryptlib、GPGME、Keyczar等，而不是诸如 OpenSSL、CryptoAPI、JCE 等易于出错且难以应用的低级别库。&lt;/p&gt;
&lt;h2 id=&#34;不要使用非认证的加密&#34;&gt;不要使用非认证的加密&lt;/h2&gt;
&lt;p&gt;这是一种非常常见的错误——&lt;strong&gt;对数据进行加密而不进行认证&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如：某开发者想保护敏感信息，使用 AES-CBC 模式对该消息进行加密。&lt;/p&gt;
&lt;p&gt;该行为仅实现了消息的机密性，但却无法保证在面临主动攻击（如篡改）、重返攻击和反射攻击等威胁时的安全性。&lt;/p&gt;
&lt;p&gt;而增加消息认证即可解决该问题。&lt;/p&gt;
&lt;p&gt;许多线上系统出现过该问题导致的严重漏洞，如 &lt;a href=&#34;http://netifera.com/research/poet/ieee-aspnetcrypto.pdf&#34;&gt;ASP.NET&lt;/a&gt;, &lt;a href=&#34;https://crypto.stackexchange.com/q/1066/351&#34;&gt;XML&lt;/a&gt; &lt;a href=&#34;https://crypto.stackexchange.com/q/1042/351&#34;&gt;encryption&lt;/a&gt;, &lt;a href=&#34;http://www.informationweek.com/news/security/vulnerabilities/231901532&#34;&gt;Amazon EC2&lt;/a&gt;, &lt;a href=&#34;http://usenix.org/events/woot10/tech/full_papers/Rizzo.pdf&#34;&gt;JavaServer Faces, Ruby on Rails, OWASP ESAPI&lt;/a&gt;, &lt;a href=&#34;http://www.cs.columbia.edu/~smb/papers/badesp.ps&#34;&gt;IPSEC&lt;/a&gt;, &lt;a href=&#34;http://www.cs.berkeley.edu/~daw/papers/wep-mob01.pdf&#34;&gt;WEP&lt;/a&gt;, &lt;a href=&#34;https://www.trustwave.com/spiderlabs/advisories/TWSL2010-001.txt&#34;&gt;ASP.NET again&lt;/a&gt;, 以及 &lt;a href=&#34;http://lasecwww.epfl.ch/pub/lasec/doc/Vau02a.ps&#34;&gt;SSH2&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;为了避免该问题，应该在每次加密时都使用消息认证，主流做法有以下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最简便的方式是，使用现成的加密认证方案，如 GCM、CWC、EAX、CCM、OCB，这些加密方法实现了加密的同时并对数据做认证，使用者无需再关心该问题；&lt;/li&gt;
&lt;li&gt;另一种方式是，自己实现消息认证。首先，使用适当的对称加密方法加密消息（例如AES-CBC），然后对密文数据生成消息认证码（如AES-CMAC, SHA1-HMAC, SHA256-HMAC），并在传输数据前，将生成的 MAC 摘要附在密文后。对于接收端，在解密数据前先验证 MAC 摘要的有效性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;不要将一个密钥同时用于加密认证或签名&#34;&gt;不要将一个密钥同时用于加密、认证或签名&lt;/h2&gt;
&lt;p&gt;一个密钥不用该重用于多种目的，这种行为会扩大风险。&lt;/p&gt;
&lt;p&gt;例如，如果你有一对 RSA 公私钥对，不应该将其既用于加密又用于签名。如果你需要加密和签名这两种行为，那么就生成两对密钥。&lt;/p&gt;
&lt;p&gt;相应的，对于对称加密而言，不应该将用于加密的密钥，用于生成消息认证码。总而言之，不要将密钥重用与不同的目的。&lt;/p&gt;
&lt;h2 id=&#34;对拼接字符串做哈希要慎重&#34;&gt;对拼接字符串做哈希要慎重&lt;/h2&gt;
&lt;p&gt;例如，某开发者想获取字符串 S 和 T 的哈希值。于是他将 S 与 T 做拼接后进行哈希运算，获得H(S||T)。这是有缺陷的。&lt;/p&gt;
&lt;p&gt;问题在于，拼接使得两个字符串的边界不明确。例如 &lt;code&gt;builtin&lt;/code&gt;||&lt;code&gt;securely&lt;/code&gt; = &lt;code&gt;built&lt;/code&gt;||&lt;code&gt;insecurely&lt;/code&gt;，哈希运算无法识别字符串 S 和 T。因此攻击者或许可以改变两个字符串的边界而不改变哈希值。例如，如果 Alice 想发送两个字符串 &lt;code&gt;builtin &lt;/code&gt;和&lt;code&gt;securely&lt;/code&gt;，攻击者可以在不使哈希值失效的情况下将字符串改为&lt;code&gt;built&lt;/code&gt;和&lt;code&gt;insecurely&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在对拼接字符串进行数字签名或消息认证码运算是也会有类似的问题。&lt;/p&gt;
&lt;p&gt;解决办法是，不进行明文拼接，而是使用可以明确解码的编码。例如，当想计算H(S||T)时，不妨改为H(length(S)||S||T)，这里length(S)是一个32位值，用以表示字符串 S 的长度；亦或者采取 H(H(S)||H(T))、H(H(S)||T) 等方式。&lt;/p&gt;
&lt;p&gt;有关该问题的相关案例参见 &lt;a href=&#34;http://rdist.root.org/2009/05/20/amazon-web-services-signature-vulnerability/&#34;&gt;this flaw in Amazon Web Services&lt;/a&gt;、 &lt;a href=&#34;http://netifera.com/research/flickr_api_signature_forgery.pdf&#34;&gt;this flaw in Flickr&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;不要重用nonces或ivs&#34;&gt;不要重用nonces或IVs&lt;/h2&gt;
&lt;p&gt;许多加密模式需要 IV（初始化向量）。永远不要重复使用同一个 IV，这样会导致严重的漏洞。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于流密码而言，例如 CTR 或 OFB 模式，会导致加密数据被轻松恢复为明文&lt;/li&gt;
&lt;li&gt;对于 CBC 等其它模式而言，重用 IV 同样会造成明文恢复攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此不管使用什么加密模式，都不应该重用 IV。&lt;/p&gt;
&lt;h2 id=&#34;确保随机数生成器具备足够的熵&#34;&gt;确保随机数生成器具备足够的熵&lt;/h2&gt;
&lt;p&gt;确保使用密码伪随机数生成器来产生key、IV、nonce等，而不是使用&lt;code&gt;rand()&lt;/code&gt;, &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;drand48()&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;确保给随机数生成器注入足够的熵，不要使用日期作为种子，这是可预测的。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;srand(time(NULL))&lt;/code&gt;并不好，比较好的方式是给随机数生成器注入128位数据或真随机数，例如通过&lt;code&gt;/dev/urandom&lt;/code&gt;, &lt;code&gt;CryptGenRandom&lt;/code&gt;或其它类似工具。在 Java 中，使用 SecureRandom 而不是 Random。在 .NET 中，使用 System.Security.Cryptography.RandomNumberGenerator，而不是 System.Random。在 Python 中，使用 random.SystemRandom，而不是 random。&lt;/p&gt;
&lt;h2 id=&#34;对于对称加密不要使用ecb模式&#34;&gt;对于对称加密，不要使用ECB模式&lt;/h2&gt;
&lt;p&gt;例如，一图片数据的明文显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/5/56/Tux.jpg&#34; alt=&#34;明文&#34;&gt;&lt;/p&gt;
&lt;p&gt;该数据经ECB模式加密后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/f/f0/Tux_ecb.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;该数据经CBC模式加密后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/a/a0/Tux_secure.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;避免使用密码作为密钥&#34;&gt;避免使用密码作为密钥&lt;/h2&gt;
&lt;p&gt;一个常见的错误做法是，使用密码或密码的哈希值作为加密密钥。密钥需要有足够的熵，而大多数密码/口令并不具备，因此容易遭到字典攻击。&lt;/p&gt;
&lt;p&gt;如果一定要基于密码来生成密钥，那么可以通过迭代哈希的方式，来增加字典攻击的难度，例如H(H(H(&amp;hellip;H(password)&amp;hellip;)))。&lt;/p&gt;
&lt;h2 id=&#34;不要使用不安全的密钥长度&#34;&gt;不要使用不安全的密钥长度&lt;/h2&gt;
&lt;p&gt;确保使用足够长的密钥，比如1024-bit 的 RSA 密钥在2010年左右已被证实不安全，建议使用至少 2048 长度的 RSA 密钥。&lt;/p&gt;
&lt;p&gt;对于对称密码而言，应使用 128-bit 以上的密钥。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git修改commit信息</title>
      <link>https://urchinzhou.com/post/git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Tue, 20 Jul 2021 15:19:14 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;修改用户名/邮箱&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1. git rebase -i &amp;#34;commit id&amp;#34; //commit id 选择目标 commit 上一次的 commit ID
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2. 修改 pick 为 edit 后，保存退出
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3. git commit --amend --author=&amp;#34;username &amp;lt;useremail&amp;gt;&amp;#34;//eg: git commit --amend --author=&amp;#34;hahaha &amp;lt;hahaha@gmail.com&amp;gt;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4. git rebase --continue
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ps:如果想修改第一次commit的信息，则步骤1中参数 commit id 改为 --root，即 git rebase -i --root
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>logcat日志读取流程分析</title>
      <link>https://urchinzhou.com/post/logcat%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 06 Jul 2021 22:30:30 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/logcat%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;logcat 通过读 &lt;strong&gt;/dev/socket/logd&lt;/strong&gt; 套接字节点，以从 &lt;strong&gt;logd&lt;/strong&gt; 进程中获取信息。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/logcat/logcat.cpp&lt;/code&gt; 的 &lt;code&gt;__logcat&lt;/code&gt; 方法中调用 &lt;code&gt;android_logger_list_read&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个野指针</title>
      <link>https://urchinzhou.com/post/%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 06 Jul 2021 22:29:13 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E6%8C%87%E9%92%88/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//常见错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;该代码段，声明了一个名为 a 的指针变量，之后将 12 存储在 a 所指向的空间中。&lt;/p&gt;
&lt;p&gt;声明了变量 a，但未对其初始化，所以并不知道 a 所指向的具体位置，即数据 12 将存储于什么地方尚未可知。&lt;/p&gt;
&lt;p&gt;声明一个指向整型的指针，不会创建用于存储整型值的内存空间。&lt;/p&gt;
&lt;p&gt;对于该代码段可能造成的结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;报错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若 a 的初始值是非法地址，则赋值语句将会报错，从而终止程序。在 UNIX 系统上，这种错误通常为“段错误（segmentation fault）”、“段违例（segmentation violation）”或“内存错误（memory fault）”。&lt;strong&gt;提示程序在试图访问一个并未分配给程序的内存位置。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不报错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若 a 的初始值刚好是一个合法的地址，则该地址的原值被新的赋值语句所覆盖，虽然你并无意修改该地址的值。这种情况下导致的错误很难发现，因为引发错误的代码大概率与原本用于操作被修改值的代码毫不相干。因此，&lt;strong&gt;在对指针进行间接访问之前，务必确保指针变量已被初始化。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>EncryptedSharedPreferences分析</title>
      <link>https://urchinzhou.com/post/encryptedsharedpreferences%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 06 Jul 2021 22:28:23 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/encryptedsharedpreferences%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;EncryptedSharedPreferenes 是 androidx 下安全组件中的加密类，实现&lt;code&gt;SharedPreferences&lt;/code&gt;的键值对加密。&lt;/p&gt;
&lt;p&gt;开发者文档中提供了&lt;code&gt;SharedPreferences&lt;/code&gt;加密键值对的实例代码，其中使用&lt;code&gt;MasterKeys&lt;/code&gt;来进行密钥管理，而在 &lt;a href=&#34;https://developer.android.com/reference/androidx/security/crypto/MasterKeys?hl=zh-cn&#34;&gt;MasterKeys&lt;/a&gt; 的文档中提示该类已废弃，应使用&lt;code&gt;MasterKey.Builder&lt;/code&gt;来管理主密钥（版本说明：基于 Jetpack Security 1.1.0-alpha01），示例如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;// this is equivalent to using deprecated MasterKeys.AES256_GCM_SPEC
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyGenParameterSpec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyGenParameterSpec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;MASTER_KEY_ALIAS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PURPOSE_ENCRYPT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PURPOSE_DECRYPT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setBlockModes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;BLOCK_MODE_GCM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setEncryptionPaddings&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KeyProperties&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ENCRYPTION_PADDING_NONE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setKeySize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KEY_SIZE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;MasterKey&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;masterKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MasterKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MainActivity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setKeyGenParameterSpec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;n&#34;&gt;EncryptedSharedPreferences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;create&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;MainActivity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;s&#34;&gt;&amp;#34;your-app-preferences-name&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;masterKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// masterKey created above
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;EncryptedSharedPreferences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PrefKeyEncryptionScheme&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;AES256_SIV&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;EncryptedSharedPreferences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PrefValueEncryptionScheme&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;AES256_GCM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>HTTPS与HTTP</title>
      <link>https://urchinzhou.com/post/https%E4%B8%8Ehttp/</link>
      <pubDate>Tue, 06 Jul 2021 22:28:02 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/https%E4%B8%8Ehttp/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;概念上理清 HTTPS 与 HTTP 的区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href=&#34;https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F&#34;&gt;互联网协议套件&lt;/a&gt;中，将网络协议分为四层，从下至上依次为&lt;strong&gt;链路层-网络层-传输层-应用层&lt;/strong&gt;，HTTP 属于应用层协议。中文名为超文本传输协议，其设计初衷是为了传输 HTML 页面。&lt;/p&gt;
&lt;p&gt;HTTP 主要规定了客户端和服务器之间的通信格式，并不涉及数据包的传输，传输依赖于 TCP/IP 协议。&lt;/p&gt;
&lt;p&gt;简单理解就是，将需要传递的数据按照 HTTP 的要求格式化（&lt;em&gt;挖坑，数据格式&lt;/em&gt;），然后剩下的交给协议栈中的 TCP/IP 层。&lt;/p&gt;
&lt;p&gt;因此基于 HTTP 协议的数据传输，其发送阶段的数据处理流程为，应用层格式化，TCP 封装，IP 封装，过程中不涉及数据的加解密，数据为明文形式传输。&lt;/p&gt;
&lt;p&gt;而 HTTPS 就是在这一流程基础上增加了安全性功能。通常可以这么理解 HTTPS， HTTPS = HTTP over TLS。（&lt;em&gt;由于安全问题，普遍已经抛弃SSL，因此这里就直接按 TLS 写了&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;TLS 表示传输层安全，从 SSL 演进而来，属于应用层与 TCP 层之间的一个协议，其目的是为互联网通信提供安全及数据完整性保障（挖坑，数据完整性），说白了就是确保数据加密传输，以及确保如果数据被篡改了，接收方能察觉到。&lt;/p&gt;
&lt;p&gt;那么 TLS 做了什么？&lt;/p&gt;
&lt;p&gt;由于要实现数据加解密，因此 TLS 要实现数据的对称加密，不用非对称加密主要是考虑到性能问题。&lt;/p&gt;
&lt;p&gt;通信双方进行数据的对称加密传输前，需要验证对端的身份，即身份认证，这一点 TLS 通过数字证书来实现（&lt;em&gt;挖坑，实现原理&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;因此基于 HTTPS 协议的数据传输，其发送阶段的数据处理流程为，应用层格式化，TLS 封装，TCP 封装，IP 封装，相较于 HTTP，流程中增加了 TLS 的处理，包括身份认证、数据加解密等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQLCipher替代SQLite</title>
      <link>https://urchinzhou.com/post/sqlcipher%E6%9B%BF%E4%BB%A3sqlite/</link>
      <pubDate>Tue, 06 Jul 2021 22:27:48 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/sqlcipher%E6%9B%BF%E4%BB%A3sqlite/</guid>
      <description>&lt;p&gt;SQLCipher 是基于 SQLite 的安全扩展，加解密行为对应用层透明，可使用标准 SQLite API 执行数据库操作，移植简单，以页为单位进行加解密操作，效率高，开销比 SQLite 多 5% 左右。&lt;/p&gt;
&lt;h3 id=&#34;安全特性&#34;&gt;安全特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加密算法使用 AES-256 CBC模式；&lt;/li&gt;
&lt;li&gt;使用口令初始化数据库，实际加密密钥根据口令派生产生，相同口令派生出的密钥不同；&lt;/li&gt;
&lt;li&gt;以页为单位加解密，默认页大小 4096 Bytes，可调整优化；&lt;/li&gt;
&lt;li&gt;对每一页写的时候，文末会附带消息验证码，用于读取时校验；&lt;/li&gt;
&lt;li&gt;加密算法由 OpenSSL libcrypto 等开源库支持；&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>TCP与粘包问题</title>
      <link>https://urchinzhou.com/post/tcp%E4%B8%8E%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 06 Jul 2021 22:26:31 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/tcp%E4%B8%8E%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;&lt;strong&gt;TCP 没有粘包问题&lt;/strong&gt;。搜索引擎中列出的各种关于“TCP 粘包问题”的文章，所讲的其实是采用 TCP 传输数据的应用层协议设计不合理导致的粘包问题，并不是 TCP 的锅。&lt;/p&gt;
&lt;p&gt;TCP 是流协议，没有粘包这个概念。&lt;/p&gt;
&lt;p&gt;所谓粘包问题，是指发送方的多条消息在传输到接收方时，由于被拼接在一起而导致无法解析的情况。要解决这一问题，需要合理设计应用层协议，约定好消息边界，以便即使多条消息被拼接在一起，也能够按照协议找到消息边界从而正确解析。&lt;/p&gt;
&lt;p&gt;之所以很多人将粘包问题看作是 TCP 造成的，是因为“拼接”这一行为发生在 TCP 层。通过 TCP 发送和接收的数据，均为数据流格式。当应用层协议使用 TCP 协议传输数据时，TCP 协议很可能将应用层发送的消息分成多个包依次发送或将多条消息组合后发送，这就会出现接收方收到的一个数据段可能由多条消息组成，即粘包。&lt;/p&gt;
&lt;p&gt;而实际情况是，TCP 本就是基于字节流而不是消息包的协议，它保证的是字节流的次序到达，对于字节流的解析应该是由应用层协议来完成的，所以&lt;strong&gt;粘包问题，实际上描述的是“如何设计应用层协议”的问题&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于gcc编译时函数符号导出的问题</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Egcc%E7%BC%96%E8%AF%91%E6%97%B6%E5%87%BD%E6%95%B0%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 06 Jul 2021 22:26:17 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Egcc%E7%BC%96%E8%AF%91%E6%97%B6%E5%87%BD%E6%95%B0%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;背景：在 Android P liblog 模块中增加一个功能，涉及外部函数调用。如在 &lt;code&gt;A.c&lt;/code&gt; 中定义函数 &lt;code&gt;fun&lt;/code&gt;，在 &lt;code&gt;A.h&lt;/code&gt; 中声明函数 &lt;code&gt;fun&lt;/code&gt;，在 &lt;code&gt;B.c&lt;/code&gt; 中包含 &lt;code&gt;A.h&lt;/code&gt; 后调用 &lt;code&gt;fun&lt;/code&gt;，文件名、路径等均没有问题，但编译时会触发 &lt;code&gt;error:undefined reference to &lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;分析：函数显然是定义了的，提示未定义应该是出于某种原因未找到。后发现 &lt;code&gt;logprint.c&lt;/code&gt; 文件中部分函数带有前缀 &lt;code&gt;LIBLOG_ABI_PUBLIC&lt;/code&gt;，该宏定义为 &lt;code&gt;#define LIBLOG_ABI_PUBLIC __attribute__((visibility(&amp;quot;default&amp;quot;)))&lt;/code&gt;，作用是设置符号的可见性属性，查看 liblog 的 Android.bp 文件，发现编译选项设置为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;cflags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;-Werror&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;-fvisibility=hidden&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可见性属性会覆盖编译时通过 &lt;code&gt;-fvisibility&lt;/code&gt; 选项指定的值，&lt;code&gt;default&lt;/code&gt; 可见性属性会使符号在所有情况下都被输出，&lt;code&gt;hidden&lt;/code&gt; 可见性属性会隐藏相应的符号。&lt;/p&gt;
&lt;p&gt;结论：该模块在编译时，通过编译选项 &lt;code&gt;&amp;quot;-fvisibility=hidden&amp;quot;&lt;/code&gt; 将符号的默认可见性属性设置为不可见，因此，对于源文件中没有显示声明为可见的函数或变量，无法被共享库的其它文件访问，从而导致编译时触发 &lt;code&gt;error:undefined reference to &lt;/code&gt;，解决办法是将需要对外共享的函数、变量的可见性属性标识为 &lt;code&gt;default&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;参考阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://my.huhoo.net/archives/2010/03/post_52.html&#34;&gt;控制符号的可见性&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于xlog加密处理分析</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Exlog%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 06 Jul 2021 22:25:57 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8Exlog%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;xlog 使用微型加密算法（TEA，Tiny Encryption Algorithm）对日志数据进行加密，使用 ECDH 密钥交换算法进行对称密钥的协商，对称密钥以数组形式存储在栈区，声明为 &lt;code&gt;LogCrypt&lt;/code&gt; 类的私有字段。&lt;/p&gt;
&lt;p&gt;会话密钥长度与椭圆曲线参数相关，xlog 中使用 16 Bytes 密钥。&lt;/p&gt;
&lt;h3 id=&#34;相关接口&#34;&gt;相关接口&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;uECC_make_key ( client_pubkey, client_pri )
&lt;ul&gt;
&lt;li&gt;生成客户端公私钥对&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;uECC_shared_secret ( svr_pubkey, client_pri, secret )
&lt;ul&gt;
&lt;li&gt;根据服务端公钥与客户端私钥，运算出对称密钥 secret&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;__TeaEncrypt ( log, secret )
&lt;ul&gt;
&lt;li&gt;使用对称密钥加密日志&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;协商流程&#34;&gt;协商流程：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;client&lt;/code&gt; 调用 &lt;code&gt;uECC_make_key&lt;/code&gt; 生成 pubKeyA 与 priKeyA；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server&lt;/code&gt; 调用 &lt;code&gt;uECC_make_key&lt;/code&gt; 生成 pubKeyB 与 priKeyB；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client&lt;/code&gt; 获取&lt;code&gt;server&lt;/code&gt; 公钥 &lt;code&gt;pubKeyB&lt;/code&gt; ，调用 &lt;code&gt;uECC_shared_secret&lt;/code&gt; 生成对称密钥 &lt;code&gt;secret&lt;/code&gt;；（此处采用 ECDH 密钥交换算法）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server&lt;/code&gt; 获取&lt;code&gt;client&lt;/code&gt; 公钥 &lt;code&gt;pubKeyA&lt;/code&gt; ，调用 &lt;code&gt;uECC_shared_secret&lt;/code&gt; 生成对称密钥 &lt;code&gt;secret&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>关于数据分片与分段</title>
      <link>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E4%B8%8E%E5%88%86%E6%AE%B5/</link>
      <pubDate>Tue, 06 Jul 2021 22:25:41 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E4%B8%8E%E5%88%86%E6%AE%B5/</guid>
      <description>&lt;p&gt;链路层要求数据帧的长度最大值为 1500 字节，该特性被称为 MTU，即最大传输单元。当 IP 层的数据报大于 MTU 时，IP 层就需要进行分片，就是把数据报分成若干片，使每一片都小于 MTU。&lt;/p&gt;
&lt;p&gt;但是，对于采用 TCP 作为传输协议的数据而言，在 IP 层是不会分片的，因为 TCP 层有一个分段的特性 —— MSS，最大分段大小。为了达到最佳传输效能，TCP 在建立连接时会协商双方的 MSS 值，这个值通常是 1460（MTU1500 - IP包头20 - TCP包头20），对于大于 1460 的数据，当到达 TCP 层时便分段了，因此 IP 层就不用分片了。&lt;/p&gt;
&lt;p&gt;而 UDP 则会产生 IP 分片，因为没有类似于 TCP 的分段特性。&lt;/p&gt;
&lt;p&gt;分片发生在网络层，分段发生在传输层。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>密码应用基础知识</title>
      <link>https://urchinzhou.com/post/%E5%AF%86%E7%A0%81%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 06 Jul 2021 22:25:17 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%AF%86%E7%A0%81%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h1 id=&#34;对称算法&#34;&gt;对称算法&lt;/h1&gt;
&lt;p&gt;加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密&lt;strong&gt;密钥是相同的&lt;/strong&gt;。这些算法也叫&lt;strong&gt;秘密密钥算法&lt;/strong&gt;或&lt;strong&gt;单密钥算法&lt;/strong&gt;，它要求发送者和接受者在安全通信之前，商定一个密钥。&lt;/p&gt;
&lt;p&gt;对称算法的安全性依赖于密钥，泄露密钥就意味着任何人都能对消息进行加密解密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对数据块运算，如果数据长度不够一块，则需要填充；加密之后数据长度可能会变长，某些场景下不适用；需要对数据进行缓存，某些场景下不适用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组算法的工作模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ECB 模式，最简单，加密长数据有风险；&lt;/li&gt;
&lt;li&gt;CBC 模式，&lt;strong&gt;最常用的工作模式&lt;/strong&gt;，但本身并没有什么优势，单纯因为过去用的人多，属于历史遗留问题；&lt;/li&gt;
&lt;li&gt;OFB 模式，效果类似于流密码，适合处理音视频数据；&lt;/li&gt;
&lt;li&gt;CFB 模式，效果类似于流密码，几乎没人用；&lt;/li&gt;
&lt;li&gt;CTR 模式，可并行加速，只要有条件就推荐使用，广泛应用于 ATM 网络安全和 IPSec 应用中；&lt;/li&gt;
&lt;li&gt;GCM、CCM 认证加密模式，既能加密又能防篡改防重放；&lt;/li&gt;
&lt;li&gt;XTS 存储加密模式，适合随机读写模式；&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>TLS协议</title>
      <link>https://urchinzhou.com/post/tls%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Tue, 06 Jul 2021 22:24:45 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/tls%E5%8D%8F%E8%AE%AE/</guid>
      <description>&lt;h2 id=&#34;tls-协议的设计目标&#34;&gt;TLS 协议的设计目标&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;构建一个安全传输层（Transport Layer Security）&lt;/strong&gt;，在基于连接的传输层（如 TCP）之上提供密码学安全，包括&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;机密性，信息加密传输，无法被窃听&lt;/li&gt;
&lt;li&gt;完整性，信息一旦被篡改，通信双方可感知&lt;/li&gt;
&lt;li&gt;认证，通信双方防止身份被冒充&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>善用阅读技巧 检视阅读</title>
      <link>https://urchinzhou.com/post/%E5%96%84%E7%94%A8%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7-%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB/</link>
      <pubDate>Tue, 06 Jul 2021 22:24:19 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%96%84%E7%94%A8%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7-%E6%A3%80%E8%A7%86%E9%98%85%E8%AF%BB/</guid>
      <description>&lt;p&gt;检视阅读（inspectional reading），强调在有限的时间内完成阅读。&lt;/p&gt;
&lt;p&gt;初次接触这一概念，是在莫提默·艾德勒所写的《如何阅读一本书》。作者从阅读技巧层面，将阅读划分为四个层次，检视阅读属于其中的第二层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层被称为&lt;strong&gt;基础阅读&lt;/strong&gt;（elementary reading），是指脱离文盲程度，能够从字面意义上完成阅读动作，基本上小学阶段即可达到这一层次。&lt;/li&gt;
&lt;li&gt;第三层被称为&lt;strong&gt;分析阅读&lt;/strong&gt;（analytical reading），相较前两层而言，更优质、更系统，摆脱了时间的限制，旨在追求抓住整本书的内容，直到彻底内化。&lt;/li&gt;
&lt;li&gt;第四层，也是最高层次的阅读，被称为&lt;strong&gt;主题阅读&lt;/strong&gt;（syntopical reading），此时的目标已经不再针对于一本书，而是围绕一个主题，开展调研式的阅读。与其称之为阅读，不如说是「研究」更为贴切。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检视阅读相较于基础阅读多了时间上的要求，比如「速读」「略读」等，都属于检视阅读的范畴，大部分成年人所采取的阅读技巧便是如此。但是掌握这一技巧的人，大多并不会充分利用这一技巧，包括我自己，在有意识地学习阅读技巧之前，对于自己所掌握并常用的技能，并没有很好地运用，从而导致阅读很低效。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何理解平均负载</title>
      <link>https://urchinzhou.com/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</link>
      <pubDate>Tue, 06 Jul 2021 22:05:40 +0800</pubDate>
      
      <guid>https://urchinzhou.com/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;平均负载不仅包括&lt;strong&gt;正在使用 CPU&lt;/strong&gt; 的进程，还包括&lt;strong&gt;等待 CPU&lt;/strong&gt; 和&lt;strong&gt;等待 I/O&lt;/strong&gt; 的进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;什么是平均负载&#34;&gt;什么是平均负载&lt;/h3&gt;
&lt;p&gt;通常我们使用 top 或 uptime 命令，来查看系统负载情况时，都会关注 load average 这一参数，但实际上你真的理解这一参数后三个数字的含义吗？相当一部分人将平均负载简单理解为单位时间内的 CPU 使用率，其实不然。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root@zwx-virtual-machine:/# uptime
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 11:06:40 up 1 day, 12 min,  1 user,  load average: 0.09, 0.04, 0.01
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;图中 load average 后的三个数字，依次是过去1分钟、5分钟、15分钟的平均负载（Load Average）。简单来说，它代表的是单位时间内，系统处于&lt;strong&gt;可运行状态&lt;/strong&gt;和&lt;strong&gt;不可中断状态&lt;/strong&gt;的平均进程数，也就是&lt;strong&gt;平均活跃进程数&lt;/strong&gt;，和 CPU 使用率并没有直接关系。&lt;/p&gt;
&lt;p&gt;所谓可运行状态的进程，是指正在使用 CPU 或正在等待 CPU 的进程，也就是使用 ps 命令看到的处于 R/Running/Runnable 状态的进程。&lt;/p&gt;
&lt;p&gt;不可中断的进程，是指正处于内核态关键流程中的进程，且这些流程是不可打断的，比如等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态进程。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>

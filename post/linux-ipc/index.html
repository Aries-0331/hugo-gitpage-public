<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Linux IPC - Aries notebook</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="IPC（进程间通信），是 Linux 系统中不同进程间进行数据交换的机制。主要包括 管道（Pipe）：主要用于父子进程通信，分为匿名管道和命名管道（FIF" /><meta name="keywords" content="Aries, blog, hugo" />






<meta name="generator" content="Hugo 0.74.3 with theme even" />


<link rel="canonical" href="https://urchinzhou.com/post/linux-ipc/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.2e81bbed97b8b282c1aeb57488cc71c8d8c8ec559f3931531bd396bf31e0d4dd.css" rel="stylesheet">



<meta property="og:title" content="Linux IPC" />
<meta property="og:description" content="IPC（进程间通信），是 Linux 系统中不同进程间进行数据交换的机制。主要包括 管道（Pipe）：主要用于父子进程通信，分为匿名管道和命名管道（FIF" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://urchinzhou.com/post/linux-ipc/" />
<meta property="article:published_time" content="2022-03-23T13:28:32+08:00" />
<meta property="article:modified_time" content="2022-03-23T13:28:32+08:00" />
<meta itemprop="name" content="Linux IPC">
<meta itemprop="description" content="IPC（进程间通信），是 Linux 系统中不同进程间进行数据交换的机制。主要包括 管道（Pipe）：主要用于父子进程通信，分为匿名管道和命名管道（FIF">
<meta itemprop="datePublished" content="2022-03-23T13:28:32+08:00" />
<meta itemprop="dateModified" content="2022-03-23T13:28:32+08:00" />
<meta itemprop="wordCount" content="9983">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux IPC"/>
<meta name="twitter:description" content="IPC（进程间通信），是 Linux 系统中不同进程间进行数据交换的机制。主要包括 管道（Pipe）：主要用于父子进程通信，分为匿名管道和命名管道（FIF"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-X"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-XXXXXXXXX-X');
</script>



</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Aries</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Aries</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Linux IPC</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-23 </span>
        <div class="post-category">
            <a href="/categories/linux/"> Linux </a>
            </div>
        
      </div>
    </header>

    
    <div class="post-content">
      <p>IPC（进程间通信），是 Linux 系统中不同进程间进行数据交换的机制。主要包括</p>
<ul>
<li>管道（Pipe）：主要用于父子进程通信，分为匿名管道和命名管道（FIFO）两种。</li>
<li>信号（Signal）：一种异步通信方式，用于通知接收信号的进程某个事件已经发生。</li>
<li>消息队列（Message Queue）：一种队列结构，可以存储要发送的消息。Linux 提供了 System V 和 POSIX 两种消息队列。</li>
<li>共享内存（Shared Memory）：最快的 IPC 机制，允许多个进程共享一段内存区域。Linux 同样提供了 System V 和 POSIX 两种共享内存。</li>
<li>信号量（Semaphore）：主要用于同步和互斥，防止多个进程同时访问共享资源。Linux 提供了 System V 和 POSIX 两种信号量。</li>
<li>套接字（Socket）：可以用于不同机器之间的进程通信，也可以用于同一机器上的进程通信（Unix Domain Socket）。</li>
</ul>
<p>这些 IPC 机制各有优缺点，选择哪种机制取决于具体的应用需求。例如，如果需要跨网络通信，那么套接字可能是最好的选择。如果需要高速通信，那么共享内存可能是最好的选择。如果只是简单的父子进程通信，那么管道可能就足够了。</p>
<p>例如在常用在命令行环境中的 <code>|</code>，就是匿名管道，它能够将一个命令的输出作为另一个命令的输入，从而使两个命令能够协同工作，如<code>ls -l | grep &quot;txt&quot;</code>、<code>cat file.txt | wc -l</code>。</p>
<h1 id="管道">管道</h1>
<p>在 Linux 系统中，管道通常是匿名的，这意味着他们没有在文件系统中显示的路径，而是通过在内核中创建的特殊文件描述符来实现。</p>
<p>创建匿名管道（Anonymous Pipes），需使用系统调用 <code>int pipe(int fd[2])</code> ，这里表示创建一个匿名管道，并返回两个描述符。一个是管道的读取端描述符<code>fd[0]</code>，另一个是写入端描述符<code>fd[1]</code>。<strong>匿名管道是特殊的文件，只存在于内存，不存在于文件系统中</strong>。</p>
<p>这里需要注意的是，在某个进程创建匿名管道，该管道的两个描述符在同一进程中，如何起到跨进程通信的作用？</p>
<p>实际上，匿名管道用于具具有亲缘关系的进程之间的通信，当我们在父进程中调用 <code>fork()</code> 系统调用创建子进程并需要父子进程通信时，父进程和子进程可以通过共享的文件描述符进行通信。</p>
<p>一般情况下，父进程关闭管道的读取端，子进程关闭管道的写入端。这样，父进程只写入，子进程只读取，避免了同时写或同时读的情况。</p>
<p>通信完成后，父子进程应该关闭不再需要的文件描述符。关闭管道的写入端（读取端）会导致对应读取端（写入端）收到一个文件结束符，这样读取操作就会返回 0，表述数据已经全部读取完毕。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//匿名管道示例
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUFFER_SIZE 25
</span><span class="cp">#define READ_END 0
</span><span class="cp">#define WRITE_END 1
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">write_msg</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Hello, pipe!&#34;</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">read_msg</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

    <span class="c1">// 创建管道
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Pipe failed&#34;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 创建子进程
</span><span class="c1"></span>    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Fork failed&#34;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 父进程
</span><span class="c1"></span>        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="n">READ_END</span><span class="p">]);</span>  <span class="c1">// 关闭读取端
</span><span class="c1"></span>
        <span class="c1">// 写入数据到管道
</span><span class="c1"></span>        <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="n">WRITE_END</span><span class="p">],</span> <span class="n">write_msg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">write_msg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="n">WRITE_END</span><span class="p">]);</span>  <span class="c1">// 关闭写入端
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent process wrote to the pipe: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">write_msg</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// 子进程
</span><span class="c1"></span>        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="n">WRITE_END</span><span class="p">]);</span>  <span class="c1">// 关闭写入端
</span><span class="c1"></span>
        <span class="c1">// 从管道中读取数据
</span><span class="c1"></span>        <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="n">READ_END</span><span class="p">],</span> <span class="n">read_msg</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Child process read from the pipe: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">read_msg</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="n">READ_END</span><span class="p">]);</span>  <span class="c1">// 关闭读取端
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于命名管道（Named Pipes，或 FIFOs），它是一种具有名称的特殊文件，存储在文件系统中，可以通过文件系统路径进行访问，允许无关进程之间进行通信，通过 <code>mkfifo</code> 命令或 <code>mkfifo()</code> 函数创建。</p>
<p>一个进程可以向命名管道中写入数据，另一个进程可以从命名管道中读取数据。其读写操作和普通文件的读写操作类似，可以使用文件 I/O 函数（<code>opoen()</code>/<code>read()/</code>/<code>write()</code>/<code>close()</code>）来进行。</p>
<p>命名管道区别于匿名管道的主要特征在于持久性，即使创建它的进程终止，命名管道仍然存在于文件系统中，直到显示地被删除。</p>
<p>所谓管道，其实就是内核里面的一串缓存。</p>
<p>当进程向管道写入数据时，内核会将数据缓存到管道的内部缓冲区。如果管道的缓冲区已满，写入操作会被阻塞，直到有足够的空间可以写入数据。类似的，当进程从管道读取数据时，内核会从管道的内部缓冲区中读取数据，并将其提供给进程。如果管道的缓冲区为空，读取操作会被阻塞，直到有数据可供读取。</p>
<p>管道的读写操作通常会涉及到进程的同步和通知机制。内核需要保证在多个进程同时访问管道时，数据的读写操作是安全和正确的。为了实现进程的同步和通知，Linux 内核可能会使用信号量、锁或者其它同步机制来保护管道的读写操作，以确保数据的一致性和正确性。</p>
<p>因此，管道这种通信方式效率低，不适合进程间频繁地交换数据。</p>
<p>总的来说，管道作为一种基本的进程间通信机制，在使用时虽然简单方便，但也存在一些弊端，主要体现在：</p>
<ol>
<li>单向通信：这意味着如果需要双向通信，需要创建两个管道，增加复杂度和开销；</li>
<li>容量限制：管道有一个固定容量限制，一般取决于操作系统的设置。一旦缓冲区达到容量上限，写入操作将被阻塞，可能导致进程间通信的延迟或死锁；</li>
<li>阻塞式读写：管道空或满时，读写操作会被阻塞，这可能导致进程被挂起，降低系统的响应速度；</li>
<li>没有数据完整性保证：管道进提供数据流传输，对完整性和可靠性没有保证，通常需要在应用层面实现额外的机制，如校验和、确认应答等；</li>
<li>无法在网络上使用：管道只能在同一台主机的进程间通信，无法用于网络通信。</li>
</ol>
<h1 id="消息队列">消息队列</h1>
<p>对于更高效、频繁传递数据的场景，可以选择使用消息队列。一般在 Linux 中，消息队列是保存在内核中的消息链表。</p>
<p>数据传输单位是用户自定义的数据，收发双方需要在传输前约定好消息体的数据类型，每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。</p>
<p>生命周期跟随系统内核，如果没有主动释放消息队列或没有关闭操作系统，消息队列会一直存在。</p>
<p>虽然消息队列可以便捷地在进程间传递数据，但它<strong>不适合大数据传输</strong>，因为在内核中每个消息体都有一个最大长度限制，同时所有队列所包含的全部消息体的总长度也有上限。内核中有两个宏定义，<code>MSGMAX</code> 和 <code>MSGMNB</code>，以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p>
<p>另外在运行效率上，<strong>通信过程存在用户态和内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，反之亦然。</p>
<p>因此，基于以上两点，消息队列更适合应用于小规模、低频率数据传输，比如任务队列（每个消息代表一个待处理的任务）、日志数据、状态更新、请求响应、数据流（数据在多个进程之间流式传输，每个消息包含流的一部分）等。</p>
<p>主要应用场景：</p>
<ol>
<li><strong>异步处理</strong>：消息队列可以用于实现异步处理，这样一来，一个进程可以将任务放入队列中，然后立即返回，而不需要等待任务完成。这对于需要长时间运行的任务特别有用，例如大数据计算或复杂的文件操作。</li>
<li><strong>负载均衡</strong>：如果有大量的任务需要处理，可以使用消息队列来分发这些任务。每个工作进程可以从队列中取出一个任务，处理它，然后再取出下一个任务。这样可以确保所有的工作进程都保持忙碌，而且可以根据需要添加更多的工作进程。</li>
<li><strong>解耦</strong>：消息队列可以用于解耦系统的不同部分。这意味着一个部分的改变不会直接影响到其他部分。例如，一个服务可以发布消息到队列，而不需要知道哪些消费者会接收和处理这些消息。</li>
<li><strong>容错</strong>：如果处理消息的进程失败，消息可以留在队列中，然后由另一个进程重新处理。这可以提高系统的可靠性。</li>
<li><strong>日志记录</strong>：消息队列可以用于收集系统的日志信息。应用程序可以将日志消息发送到队列，然后由专门的日志服务从队列中读取和处理这些消息。</li>
</ol>
<p>消息队列的常用系统调用接口：<code>mq_open()</code> / <code>mq_send()</code> / <code>mq_receive()</code> / <code>mq_close()</code> / <code>mq_unlink()</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define QUEUE_NAME &#34;/my_message_queue&#34;
</span><span class="cp">#define MAX_MSG_SIZE 256
</span><span class="cp">#define MAX_MSG_COUNT 10
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mqd_t</span> <span class="n">mq</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX_MSG_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">msg_flags</span> <span class="o">=</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">;</span>
    <span class="n">mode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">;</span> <span class="c1">// Permissions for the message queue
</span><span class="c1"></span>
    <span class="c1">// Set up the attributes of the message queue
</span><span class="c1"></span>    <span class="n">attr</span><span class="p">.</span><span class="n">mq_maxmsg</span> <span class="o">=</span> <span class="n">MAX_MSG_COUNT</span><span class="p">;</span>
    <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span> <span class="o">=</span> <span class="n">MAX_MSG_SIZE</span><span class="p">;</span>
    <span class="n">attr</span><span class="p">.</span><span class="n">mq_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Create the message queue
</span><span class="c1"></span>    <span class="n">mq</span> <span class="o">=</span> <span class="n">mq_open</span><span class="p">(</span><span class="n">QUEUE_NAME</span><span class="p">,</span> <span class="n">msg_flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mq</span> <span class="o">==</span> <span class="p">(</span><span class="n">mqd_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;mq_open&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message queue created.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="c1">// Send a message to the queue
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Enter message to send: &#34;</span><span class="p">);</span>
    <span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">MAX_MSG_SIZE</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mq_send</span><span class="p">(</span><span class="n">mq</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;mq_send&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message sent.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="c1">// Receive a message from the queue
</span><span class="c1"></span>    <span class="n">ssize_t</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mq</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX_MSG_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bytes_read</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;mq_receive&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">buffer</span><span class="p">[</span><span class="n">bytes_read</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Received message: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

    <span class="c1">// Close the message queue
</span><span class="c1"></span>    <span class="n">mq_close</span><span class="p">(</span><span class="n">mq</span><span class="p">);</span>

    <span class="c1">// Remove the message queue
</span><span class="c1"></span>    <span class="n">mq_unlink</span><span class="p">(</span><span class="n">QUEUE_NAME</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="共享内存">共享内存</h1>
<p>现代操作系统的内存管理，采用虚拟内存技术，即每个进程有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和进程 B 的虚拟地址一样，其访问的物理内存地址也是不同的，对于数据的增删改查互不影响。</p>
<p>而共享内存则是<strong>将相同的虚拟地址空间映射到同一的物理内存中</strong>，以实现不同进程在同一内存区域共同增删改查，从而无需拷贝、无需进行用户态内核态切换，大大提升了 IPC 速度，且相对于消息队列而言，其传递数据的大小仅受限于系统的物理内存大小，处理大数据的能力远大于消息队列。常用于数据库系统、图像处理和科学计算等。</p>
<p>使用共享内存作为 IPC 方式，需要重点关注<strong>同步</strong>和<strong>安全</strong>问题。多个进程同时访问共享内存可能导致数据不一致，因此需要使用同步机制（如信号量）来确保数据一致性。另外，任何可以访问共享内存的进程都可以修改数据，容易导致安全问题（如意外或恶意篡改）。因此在创建共享内存时，可以通过设置权限进行访问控制，读写数据时进行适当的完整性校验，以增强安全性。</p>
<p>这里提供一个简单示例，首先是创建和向共享内存写数据的进程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/shm.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;OS&#34;</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message_0</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message_1</span> <span class="o">=</span> <span class="s">&#34;World!&#34;</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sem_name</span> <span class="o">=</span> <span class="s">&#34;sem&#34;</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">shm_fd</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">;</span>

    <span class="cm">/* 创建共享内存对象 */</span>
    <span class="n">shm_fd</span> <span class="o">=</span> <span class="n">shm_open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shm_fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In shm_open&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 配置共享内存对象的大小 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ftruncate</span><span class="p">(</span><span class="n">shm_fd</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In ftruncate&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 将共享内存对象映射到内存 */</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">,</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">shm_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In mmap&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 创建信号量 */</span>
    <span class="n">sem</span> <span class="o">=</span> <span class="n">sem_open</span><span class="p">(</span><span class="n">sem_name</span><span class="p">,</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="mo">0666</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sem</span> <span class="o">==</span> <span class="n">SEM_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In sem_open&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 将数据写入共享内存对象 */</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">message_0</span><span class="p">);</span>
    <span class="n">ptr</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message_0</span><span class="p">);</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">message_1</span><span class="p">);</span>
    <span class="n">ptr</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message_1</span><span class="p">);</span>

    <span class="cm">/* 通过信号量通知其他进程可以读取数据 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sem_post</span><span class="p">(</span><span class="n">sem</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In sem_post&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后是读数据和删除共享内存的进程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/shm.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;OS&#34;</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sem_name</span> <span class="o">=</span> <span class="s">&#34;sem&#34;</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">shm_fd</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">;</span>

    <span class="cm">/* 打开共享内存对象 */</span>
    <span class="n">shm_fd</span> <span class="o">=</span> <span class="n">shm_open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shm_fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In shm_open&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 将共享内存对象映射到内存 */</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">shm_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In mmap&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 打开信号量 */</span>
    <span class="n">sem</span> <span class="o">=</span> <span class="n">sem_open</span><span class="p">(</span><span class="n">sem_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sem</span> <span class="o">==</span> <span class="n">SEM_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In sem_open&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 等待信号量 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sem_wait</span><span class="p">(</span><span class="n">sem</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In sem_wait&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 从共享内存中读取数据 */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>

    <span class="cm">/* 删除共享内存对象 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shm_unlink</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In shm_unlink&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 删除信号量 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sem_unlink</span><span class="p">(</span><span class="n">sem_name</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;In sem_unlink&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个示例中，使用了一个信号量来同步两个进程的操作。写入进程在写入数据后通过信号量通知读取进程可以读取数据。读取进程在读取数据前等待信号量。另外，添加了一些错误处理和安全性检查，例如检查 <code>shm_open</code>、<code>ftruncate</code>、<code>mmap</code>、<code>sem_open</code>、<code>sem_post</code>、<code>sem_wait</code>、<code>shm_unlink</code> 和 <code>sem_unlink</code> 的返回值，并在出错时打印错误消息并退出。</p>
<p>这里可以明显看出，相较于前两种 IPC 机制，要想获得更高的效率，就要关注更多的细节，这里有几个要点需要关注：</p>
<ol>
<li><strong>同步访问</strong>：当多个进程访问共享内存时，必须使用某种同步机制（如信号量或互斥锁）来确保数据的一致性和完整性。</li>
<li><strong>清理共享内存</strong>：当所有进程都不再需要共享内存时，应该删除它以释放系统资源。在 Linux 中，可以使用 <code>shmctl</code> 函数（对于 System V 共享内存）或 <code>shm_unlink</code> 函数（对于 POSIX 共享内存）来删除共享内存。</li>
<li><strong>错误处理</strong>：在使用共享内存的过程中，应该检查所有可能的错误条件，并适当地处理错误。</li>
<li><strong>避免使用过大的共享内存区域</strong>：虽然共享内存是一种高效的 IPC 机制，但是使用过大的共享内存区域可能会消耗大量的系统资源，并可能导致性能问题。</li>
<li><strong>使用适当的数据结构</strong>：在共享内存中，应该使用适合并发访问的数据结构。例如，如果多个进程需要同时读写一个数据结构，那么应该使用一个可以支持并发访问的数据结构，如链表或哈希表。</li>
<li><strong>避免使用指针</strong>：在共享内存中，不应该使用指向非共享内存区域的指针，因为这些指针在其他进程中可能无效。</li>
<li><strong>安全性</strong>：共享内存可以被任何具有适当权限的进程访问，因此应该考虑数据的安全性。如果需要，可以使用加密和解密机制来保护数据。</li>
</ol>
<h1 id="信号量">信号量</h1>
<p>在上面的示例代码中，除了共享内存，还引入了另一种 IPC 机制，信号量（Semaphore），以解决共享内存的访问同步问题。</p>
<p><strong>信号量其实是一个整形的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</strong></p>
<p>其在 Linux 内核中的定义为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">semaphore</span> <span class="p">{</span>
    <span class="n">raw_spinlock_t</span>      <span class="n">lock</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">count</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span>    <span class="n">wait_list</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>其中：</p>
<ul>
<li><code>lock</code> 是一个原始的自旋锁，用于保护信号量的数据结构。</li>
<li><code>count</code> 是信号量的当前值。当一个进程调用 <code>down</code> 或 <code>sem_wait</code> 函数试图获取信号量时，如果 <code>count</code> 大于 0，那么 <code>count</code> 将减 1，进程将继续执行。如果 <code>count</code> 等于 0，那么进程将被阻塞，直到 <code>count</code> 变为非 0.</li>
<li><code>wait_list</code> 是一个链表，包含了所有等待这个信号量的进程。</li>
</ul>
<p>控制信号量的方式有两种原子操作，P 操作和 V 操作。</p>
<ul>
<li>P 操作，也被称为 ”wait” 或 “down” 操作。当一个进程需要访问共享资源时，它会执行 P 操作，在 P 操作中，信号量的值会减 1。</li>
<li>V 操作，也被称为 “signal” 或 ”up“ 操作。当一个进程完成对共享资源的访问后，它会执行 V 操作，在 V 操作中，信号量的值会加 1。</li>
</ul>
<blockquote>
<p>P 操作和 V 操作这两种术语源自荷兰语，P 操作来自 “Proberen”，意为“尝试”，V 操作来自 “Verhogen”， 意为“增加“。</p>
<p>原子操作是指在多线程环境中，一个不可被中断的操作，也就是说这个操作要么完全执行，要么完全不执行，不会出现执行一半的情况。在执行过程中，不会被其他线程打断。</p>
</blockquote>
<p>前面我们提到，信号量相当于一个计数器，当信号量被初始化为 1 时，先到来的 P 操作进程先占用资源，后来的 P 操作都得阻塞等待，保证共享内存在任何时刻只有一个进程在访问，<strong>此时的信号量是作为互斥信号量</strong>。</p>
<p>如果初始化为 0 呢？</p>
<p>通常在多进程里，每个进程各自独立运行，先后顺序不可知，当我们希望多个进程能合作实现一个任务时，可以将信号量初始化为 0。例如，进程 A 是数据生产者，进程 B 是数据消费者，显然 B 依赖 A，此时若 B 比 A 先执行，当其执行到 P 操作时，由于信号量为 0，B 阻塞，直到 A 执行了 V 操作，相当于唤醒了阻塞在 P 操作的 B 进程，<strong>此时的信号量是作为同步信号量</strong>，保证进程 A 的 V 操作先于进程 B 的 P 操作执行。</p>
<p>这是经典的生产者-消费者问题，也是信号量比较常见的应用场景。</p>
<p>比较常用的信号量操作如<code>sem_init()</code>/<code>sem_wait()</code>/<code>sem_post()</code>/<code>sem_destroy()</code>等，可以在<code>semaphore.h</code>头文件中找到，这里做个简单记录：</p>
<ol>
<li><strong><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></strong>：
<ul>
<li>初始化一个新的信号量。</li>
<li><code>sem</code>：指向要初始化的信号量的指针。</li>
<li><code>pshared</code>：指定信号量的共享性质，如果为 0 则表示信号量是进程内共享，非 0 值表示信号量是在进程之间共享的（通常用于线程间通信）。</li>
<li><code>value</code>：指定信号量的初始值。</li>
</ul>
</li>
<li><strong><code>int sem_wait(sem_t *sem);</code></strong>：
<ul>
<li>等待信号量，如果信号量的值大于 0，则将其减一；如果信号量的值为 0，则阻塞直到信号量的值大于 0。</li>
<li><code>sem</code>：指向待操作的信号量的指针。</li>
</ul>
</li>
<li><strong><code>int sem_post(sem_t *sem);</code></strong>：
<ul>
<li>释放信号量，将信号量的值加一。</li>
<li><code>sem</code>：指向待操作的信号量的指针。</li>
</ul>
</li>
<li><strong><code>int sem_destroy(sem_t *sem);</code></strong>：
<ul>
<li>销毁信号量，释放信号量相关的资源。</li>
<li><code>sem</code>：指向待销毁的信号量的指针。</li>
</ul>
</li>
</ol>
<p>使用信号量时有两个要注意的点，一是注意处理各种边界条件以防死锁，二是确保使用完后及时释放信号量避免资源泄露。以如下代码为例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUFFER_SIZE 5
</span><span class="cp"></span>
<span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">full</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>

        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

        <span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Produced item: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
        <span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>

        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>

        <span class="c1">// Sleep for random time
</span><span class="c1"></span>        <span class="n">sleep</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>
        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

        <span class="n">item</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">];</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Consumed item: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>

        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>

        <span class="c1">// Sleep for random time
</span><span class="c1"></span>        <span class="n">sleep</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Initialize semaphores
</span><span class="c1"></span>    <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
    <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Create producer and consumer threads
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">producer_thread</span><span class="p">,</span> <span class="n">consumer_thread</span><span class="p">;</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">producer_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">producer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consumer_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consumer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Join threads
</span><span class="c1"></span>    <span class="n">pthread_join</span><span class="p">(</span><span class="n">producer_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">consumer_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Destroy semaphores
</span><span class="c1"></span>    <span class="n">sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
    <span class="n">sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>在这个示例中，边界条件主要涉及到缓冲区的使用和信号量的初始值设置。</p>
<ol>
<li><strong>缓冲区边界</strong>：
<ul>
<li>在生产者往缓冲区写入数据时，需要确保缓冲区不会溢出，即当<code>in</code>指针超出缓冲区边界时，将其置为 0，实现循环缓冲。</li>
<li>在消费者从缓冲区读取数据时，需要确保缓冲区不会读取到无效数据，即当<code>out</code>指针超出缓冲区边界时，将其置为 0，实现循环缓冲。</li>
</ul>
</li>
<li><strong>信号量初始值</strong>：
<ul>
<li><code>empty</code>信号量的初始值应该等于缓冲区的大小，表示缓冲区中可用的空闲位置数量。</li>
<li><code>full</code>信号量的初始值应该为 0，表示缓冲区中已经存放的数据数量。</li>
</ul>
</li>
</ol>
<p>通过正确处理这些边界条件，可以确保生产者和消费者线程在访问共享资源（即缓冲区）时不会发生溢出或越界的情况，保证程序的正确性和稳定性。</p>
<h1 id="信号">信号</h1>
<p>以上 IPC 机制，主要用于程序正常运行时，在程序异常时，就需要另一种 IPC 机制&ndash;信号，来进行跨进程通信。</p>
<p>信号允许一个进程向另一个进程发送通知，告诉对方某个事件已经发生或请求执行某个操作。信号是一种轻量级通信方式，常用于实现进程的异步事件处理、进程间同步和异常处理等。</p>
<p>信号有如下四种基本特性：</p>
<ol>
<li><strong>编号</strong>：每个信号都有一个唯一的编号，通常用整数表示，例如 SIGINT 表示中断信号。</li>
<li><strong>发送</strong>：一个进程可以通过调用<code>kill()</code>函数向另一个进程发送信号，或者在终端键入特定的终端控制字符（比如 Ctrl+C 发送 SIGINT 信号）。</li>
<li><strong>处理</strong>：接收到信号的进程可以选择忽略信号、执行默认操作或者注册信号处理函数。</li>
<li><strong>异步</strong>：信号是异步事件，即发送信号的进程和接收信号的进程之间没有直接的通信通道。</li>
</ol>
<p>常见的系统信号（部分信号在不同的系统上可能有所不同）：</p>
<ul>
<li><strong>SIGINT</strong>：中断信号，通常由用户按下 Ctrl+C 发送，用于中断进程。</li>
<li><strong>SIGTERM</strong>：终止信号，用于请求进程正常终止。</li>
<li><strong>SIGKILL</strong>：强制终止信号，用于立即终止进程。</li>
<li><strong>SIGUSR1</strong>和<strong>SIGUSR2</strong>：用户定义的信号，可以由应用程序自定义使用。</li>
<li><strong>SIGSEGV</strong>：段错误信号，表示进程访问了无效的内存地址。</li>
<li><strong>SIGCHLD</strong>：子进程状态改变信号，用于通知父进程子进程的状态改变。</li>
</ul>
<p>对于每个信号，操作系统都定义了默认的处理方式，比如终止进程或者忽略信号。不过进程可以为特定信号注册自定义的信号处理函数，当接收到该信号时，执行相应的处理逻辑。另外，可以通过设置信号屏蔽来暂时阻塞某些信号，以避免在关键时刻被中断。信号的操作以轻、快为主，其处理函数要尽量保持简单和安全，避免调用不可重入函数、执行复杂或阻塞的操作。</p>
<p>基本使用方式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Received signal: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">signum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 注册信号处理函数
</span><span class="c1"></span>    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">);</span> <span class="c1">// Ctrl+C中断信号
</span><span class="c1"></span>    <span class="n">signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">);</span> <span class="c1">// 终止信号
</span><span class="c1"></span>
    <span class="c1">// 进入无限循环等待信号
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="socket">Socket</h1>
<p>前面五中 IPC 机制都是在同一台主机上进行进程间通信，而 Socket 可以实现跨网络、跨主机的进程间通信，当然它也可以用于同主机的进程间通信。而在前面介绍的 IPC 机制中，在进程间通信时都是通过 PID 来唯一标识进程，在跨主机的情况下，Socket 该如何唯一标识一个进程？</p>
<p>Socket 表面上是一个 Linux 文件系统的特殊文件，一组 API，实际上它还是 TCP/IP 协议族的应用层抽象。借助 TCP/IP，可以通过网络层的 IP 地址唯一标识网络中的主机，通过传输层的协议和端口唯一标识主机中的进程。IP+协议+端口，便是 Socket 唯一标识一个进程的方式。</p>
<p>Socket API 的调用流程受创建 Socket 时选择的通信类型影响，这是创建 socket 的系统调用：</p>
<p><code>int socket(int domain, int type, int protocal)</code></p>
<ul>
<li><code>domain</code>：指定地址族，常见的有<code>AF_INET</code>（IPv4 地址族）和<code>AF_INET6</code>（IPv6 地址族）等。</li>
<li><code>type</code>：指定 Socket 的类型，常见的有<code>SOCK_STREAM</code>（流式 Socket，用于 TCP）和<code>SOCK_DGRAM</code>（数据报 Socket，用于 UDP）等。</li>
<li><code>protocol</code>：指定协议，通常为 0 表示使用默认协议。</li>
</ul>
<p>当创建的 socket 类型为 TCP 时，服务端需要监听 socket 以等待连接请求，在客户端发来连接请求时，双方需要进行三次握手，连接成功后会创建一个新的 socket 用于与客户端通信，而后进行正式的数据传输。以下是一个简单的 TCP Socket 示例，包括一个简单的服务器端和一个客户端，演示了如何建立 TCP 连接并进行数据传输：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//tcp_server.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define PORT 8080
</span><span class="cp">#define BUFFER_SIZE 1024
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">server_fd</span><span class="p">,</span> <span class="n">new_socket</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">address</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">welcome_message</span> <span class="o">=</span> <span class="s">&#34;Welcome to the server!&#34;</span><span class="p">;</span>

    <span class="c1">// 创建TCP Socket
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">server_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;socket failed&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 绑定地址和端口
</span><span class="c1"></span>    <span class="n">address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;bind failed&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 监听连接
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;listen&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 等待连接
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">new_socket</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="p">(</span><span class="n">socklen_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addrlen</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;accept&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 发送欢迎消息给客户端
</span><span class="c1"></span>    <span class="n">send</span><span class="p">(</span><span class="n">new_socket</span><span class="p">,</span> <span class="n">welcome_message</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">welcome_message</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Welcome message sent to client</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="c1">// 接收客户端消息并回复
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">valread</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">valread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">new_socket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Client: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
        <span class="n">send</span><span class="p">(</span><span class="n">new_socket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Closing connection...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">new_socket</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">server_fd</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//tcp_client.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define PORT 8080
</span><span class="cp">#define BUFFER_SIZE 1024
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">valread</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello from client&#34;</span><span class="p">;</span>

    <span class="c1">// 创建TCP Socket
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;socket creation error&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

    <span class="c1">// 将IP地址转换为网络字节序
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="s">&#34;127.0.0.1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;Invalid address/ Address not supported&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 连接服务器
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;Connection failed&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 发送消息给服务器
</span><span class="c1"></span>    <span class="n">send</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message sent to server</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="c1">// 接收服务器的回复
</span><span class="c1"></span>    <span class="n">valread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Server: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">buffer</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>在 TCP Socket 通信的过程中，数据的可靠传输是由 TCP 协议来保证的，它会确保数据的顺序交付和可靠性。因此，在使用 TCP Socket 进行通信时，无需过多考虑数据的丢失和顺序问题，只需要关注如何正确地发送和接收数据即可。</p>
<p>当创建的 socket 类型为 UDP 时，与 TCP 不同，UDP 不会事先建立连接（也就是不握手），也不维护连接的状态信息，这就导致每个数据包都是独立的，发送和接收都是无状态的。而相应的这种机制也造就了其低延迟高效率的优势，适用于对数据传输实时性要求较高的场景。以下是一个简单的 UDP Socket 示例，包括一个服务器端和一个客户端，演示了如何使用 UDP Socket 进行通信：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//udp_server.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define PORT 8080
</span><span class="cp">#define BUFFER_SIZE 1024
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>

    <span class="c1">// 创建UDP Socket
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;socket creation failed&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">));</span>

    <span class="c1">// 设置服务器地址信息
</span><span class="c1"></span>    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

    <span class="c1">// 将Socket绑定到地址和端口上
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;bind failed&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 接收数据
</span><span class="c1"></span>        <span class="n">n</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="n">MSG_WAITALL</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
        <span class="n">buffer</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Client : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

        <span class="c1">// 发送数据
</span><span class="c1"></span>        <span class="n">sendto</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">MSG_CONFIRM</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message sent to client.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//udp_client.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define PORT 8080
</span><span class="cp">#define BUFFER_SIZE 1024
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello from client&#34;</span><span class="p">;</span>

    <span class="c1">// 创建UDP Socket
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;socket creation failed&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>

    <span class="c1">// 设置服务器地址信息
</span><span class="c1"></span>    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>
    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">);</span>

    <span class="c1">// 发送数据
</span><span class="c1"></span>    <span class="n">sendto</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">message</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <span class="n">MSG_CONFIRM</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message sent to server.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="c1">// 接收回复
</span><span class="c1"></span>    <span class="n">n</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="n">MSG_WAITALL</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Server : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h1 id="posix--system-v">POSIX &amp; System V</h1>
<p>POSIX (Portable Operating System Interface) 和 System V 是两种不同的 Unix 标准。它们在很多方面都有所不同，包括它们提供的进程间通信（IPC）机制。</p>
<p>以下是它们在 IPC 方面的一些主要区别：</p>
<ol>
<li><strong>消息队列</strong>：System V 提供了 <code>msgget</code>，<code>msgsnd</code>，<code>msgrcv</code> 和 <code>msgctl</code> 系统调用来操作消息队列。而 POSIX 提供了 <code>mq_open</code>，<code>mq_send</code>，<code>mq_receive</code>，<code>mq_close</code> 和 <code>mq_unlink</code> 函数来操作消息队列。POSIX 消息队列支持优先级，而 System V 消息队列支持消息类型。</li>
<li><strong>信号量</strong>：System V 提供了 <code>semget</code>，<code>semop</code> 和 <code>semctl</code> 系统调用来操作信号量。而 POSIX 提供了 <code>sem_open</code>，<code>sem_wait</code>，<code>sem_post</code>，<code>sem_close</code> 和 <code>sem_unlink</code> 函数来操作信号量。POSIX 信号量可以在进程间或线程间使用，而 System V 信号量主要用于进程间。</li>
<li><strong>共享内存</strong>：System V 提供了 <code>shmget</code>，<code>shmat</code>，<code>shmdt</code> 和 <code>shmctl</code> 系统调用来操作共享内存。而 POSIX 提供了 <code>shm_open</code>，<code>mmap</code>，<code>munmap</code>，<code>shm_unlink</code> 函数来操作共享内存。</li>
<li><strong>命名和生命周期</strong>：System V IPC 对象通过 key 和 id 来标识，需要显式删除，否则会一直存在。而 POSIX IPC 对象通过名字来标识，可以设置自动删除，当最后一个引用关闭后，对象会被自动删除。</li>
<li><strong>接口</strong>：POSIX 的接口通常更简单，更易于使用，而 System V 的接口则更复杂，提供了更多的选项和功能。</li>
</ol>
<p>至于选择哪种类型的 IPC 机制，主要取决于具体的应用需求和开发者的偏好。</p>
<p>一般情况下，我们可能会偏向于选择 POSIX IPC 机制，主要原因在于：</p>
<ol>
<li><strong>接口一致性</strong>：POSIX IPC 机制的接口在不同的 Unix-like 系统（包括 Linux）之间保持一致，这有助于提高代码的可移植性。</li>
<li><strong>更现代的特性</strong>：相比于 System V，POSIX IPC 机制提供了一些更现代的特性，例如更好的线程支持、更灵活的命名机制以及更好的资源管理等。</li>
</ol>
<p>然而，这并不意味着 System V IPC 机制没有用武之地。在一些特定的场景下，System V IPC 机制可能会是更好的选择，例如：</p>
<ol>
<li><strong>更丰富的功能</strong>：System V IPC 机制提供了一些 POSIX IPC 机制所不具备的功能，例如消息队列中的消息类型、信号量操作的原子性等。</li>
<li><strong>更广泛的兼容性</strong>：由于 System V IPC 机制的历史更为悠久，因此它在一些较旧的系统中可能会得到更好的支持。</li>
</ol>
<p>总的来说，Linux 系统并没有默认采取 POSIX 还是 System V，而是提供了这两种 IPC 机制供开发者根据具体的需求和偏好进行选择。</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%87%92%E5%8A%A0%E8%BD%BD/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">懒加载</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/javsscript-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/">
            <span class="next-text nav-default">JavsScript 箭头函数</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:urchinzhou@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/AriesBlabla" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/Aries-0331" class="iconfont icon-github" title="github"></a>
  <a href="https://urchinzhou.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-X"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-XXXXXXXXX-X');
</script>








</body>
</html>
